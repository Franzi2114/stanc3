$ node allow-undefined.js
Semantic error in 'string', line 3, column 8 to column 11: 
Function is declared without specifying a definition.

$ node auto-format.js
parameters {
  real y;
}
model {
  y ~ std_normal();
}

$ node basic.js
Semantic error in 'string', line 6, column 4 to column 5: 
Identifier 'z' not in scope.

$ node canonical.js
transformed data {
  real a = lmultiply(4, 5);
}
parameters {
  real y;
}
model {
  y ~ normal(0, 1);
}

$ node data-generation.js
{
"x": [[6, 2, 4, 2], [3, 2, 6, 2], [6, 3, 4, 2]],
"y":
  [[[6, 5, 5, 5], [6, 3, 2, 5]], [[6, 2, 6, 6], [2, 5, 5, 2]],
    [[4, 4, 4, 3], [2, 4, 6, 2]], [[2, 5, 3, 6], [5, 5, 6, 5]],
    [[6, 6, 5, 3], [3, 4, 2, 5]]],
"z":
  [[5.8530474347281336, 6.3955297933730639, 6.4404632518168468,
     5.8926590620580992],
    [5.8815901469879766, 3.9191590616049568, 3.7206314135215708,
      2.171635388977561],
    [4.925001387848174, 6.97212837743693, 2.8719106043920211,
      5.3835056697400123]],
"w": [2.9621789585306804, 5.5083017771155482, 5.505904011446936],
"p":
  [[5.2217505923869556, 2.0493220812048105, 3.1335081619228875],
    [2.3086085754863221, 5.0735880143406691, 4.9955866267343172],
    [6.7239589323018487, 6.0503609645580525, 6.1832136714928119],
    [2.9385807829191903, 5.5620586856883119, 6.2768699310734206]]
}
$ node filename.js
Semantic error in 'good_filename', line 6, column 4 to column 5: 
Identifier 'z' not in scope.

Semantic error in 'string', line 6, column 4 to column 5: 
Identifier 'z' not in scope.

$ node functions-only.js

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace functions_only_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 21> locations_array__ = 
{" (found before start of program)",
 " (in 'string', line 3, column 4 to column 24)",
 " (in 'string', line 2, column 26 to line 4, column 1)",
 " (in 'string', line 8, column 4 to column 18)",
 " (in 'string', line 7, column 0 to line 9, column 1)",
 " (in 'string', line 13, column 4 to column 18)",
 " (in 'string', line 12, column 0 to line 14, column 1)",
 " (in 'string', line 18, column 11 to column 26)",
 " (in 'string', line 18, column 4 to column 45)",
 " (in 'string', line 19, column 4 to column 18)",
 " (in 'string', line 17, column 0 to line 20, column 1)",
 " (in 'string', line 23, column 4 to column 15)",
 " (in 'string', line 22, column 42 to line 24, column 1)",
 " (in 'string', line 27, column 4 to column 21)",
 " (in 'string', line 26, column 25 to line 28, column 1)",
 " (in 'string', line 32, column 4 to column 21)",
 " (in 'string', line 31, column 21 to line 33, column 1)",
 " (in 'string', line 36, column 4 to column 28)",
 " (in 'string', line 35, column 22 to line 37, column 1)",
 " (in 'string', line 40, column 4 to column 33)",
 " (in 'string', line 39, column 31 to line 41, column 1)"};


template <typename T0__>
stan::promote_args_t<T0__>
my_log1p_exp(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 1;
    return log1p_exp(x);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}

struct my_log1p_exp_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const T0__& x, std::ostream* pstream__)  const 
{
return my_log1p_exp(x, pstream__);
}
};

template <typename T0__>
stan::promote_args_t<T0__>
array_fun(const std::vector<T0__>& a, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 3;
    return sum(a);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}

struct array_fun_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const std::vector<T0__>& a, std::ostream* pstream__)  const 
{
return array_fun(a, pstream__);
}
};

double
int_array_fun(const std::vector<int>& a, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 5;
    return sum(a);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}

struct int_array_fun_functor__ {
double
operator()(const std::vector<int>& a, std::ostream* pstream__)  const 
{
return int_array_fun(a, pstream__);
}
};

template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
my_vector_mul_by_5(const T0__& x_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
  int current_statement__ = 0; 
  const auto& x = to_ref(x_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 7;
    validate_non_negative_index("result", "num_elements(x)", num_elements(x));
    Eigen::Matrix<local_scalar_t__, -1, 1> result;
    result = Eigen::Matrix<local_scalar_t__, -1, 1>(num_elements(x));
    stan::math::fill(result, DUMMY_VAR__);
    
    current_statement__ = 8;
    assign(result, multiply(x, 5.0), "assigning variable result");
    current_statement__ = 9;
    return result;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}

struct my_vector_mul_by_5_functor__ {
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
operator()(const T0__& x, std::ostream* pstream__)  const 
{
return my_vector_mul_by_5(x, pstream__);
}
};

int
int_only_multiplication(const int& a, const int& b, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 11;
    return (a * b);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}

struct int_only_multiplication_functor__ {
int
operator()(const int& a, const int& b, std::ostream* pstream__)  const 
{
return int_only_multiplication(a, b, pstream__);
}
};

template <typename T0__>
stan::promote_args_t<T0__>
test_lgamma(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 13;
    return stan::math::lgamma(x);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}

struct test_lgamma_functor__ {
template <typename T0__>
stan::promote_args_t<T0__>
operator()(const T0__& x, std::ostream* pstream__)  const 
{
return test_lgamma(x, pstream__);
}
};

template <bool propto__, typename T0__, typename T_lp__,
typename T_lp_accum__>
void
test_lp(const T0__& a, T_lp__& lp__, T_lp_accum__& lp_accum__,
        std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0; 
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 15;
    lp_accum__.add(normal_lpdf<propto__>(a, 0, 1));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}

struct test_lp_functor__ {
template <bool propto__, typename T0__, typename T_lp__,
typename T_lp_accum__>
void
operator()(const T0__& a, T_lp__& lp__, T_lp_accum__& lp_accum__,
           std::ostream* pstream__)  const 
{
return test_lp<propto__>(a, lp__, lp_accum__, pstream__);
}
};

template <typename T0__, typename RNG>
stan::promote_args_t<T0__>
test_rng(const T0__& a, RNG& base_rng__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__>;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 17;
    return normal_rng(a, 1, base_rng__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}

struct test_rng_functor__ {
template <typename T0__, typename RNG>
stan::promote_args_t<T0__>
operator()(const T0__& a, RNG& base_rng__, std::ostream* pstream__)  const 
{
return test_rng(a, base_rng__, pstream__);
}
};

template <bool propto__, typename T0__, typename T1__>
stan::promote_args_t<T0__,
T1__>
test_lpdf(const T0__& a, const T1__& b, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  int current_statement__ = 0; 
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 19;
    return normal_lpdf<false>(a, b, 1);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
  }
  
}

struct test_lpdf_functor__ {
template <bool propto__, typename T0__, typename T1__>
stan::promote_args_t<T0__,
T1__>
operator()(const T0__& a, const T1__& b, std::ostream* pstream__)  const 
{
return test_lpdf<propto__>(a, b, pstream__);
}
};


}

// [[stan::function]]
auto my_log1p_exp(const double& x, std::ostream* pstream__ = nullptr)  
{
 return functions_only_namespace::my_log1p_exp(x, pstream__);
}


// [[stan::function]]
auto array_fun(const std::vector<double>& a,
               std::ostream* pstream__ = nullptr)  
{
 return functions_only_namespace::array_fun(a, pstream__);
}


// [[stan::function]]
auto int_array_fun(const std::vector<int>& a,
                   std::ostream* pstream__ = nullptr)  
{
 return functions_only_namespace::int_array_fun(a, pstream__);
}


// [[stan::function]]
auto my_vector_mul_by_5(const Eigen::Matrix<double, -1, 1>& x,
                        std::ostream* pstream__ = nullptr)  
{
 return functions_only_namespace::my_vector_mul_by_5(x, pstream__);
}


// [[stan::function]]
auto int_only_multiplication(const int& a, const int& b,
                             std::ostream* pstream__ = nullptr)  
{
 return functions_only_namespace::int_only_multiplication(a, b, pstream__);
}


// [[stan::function]]
auto test_lgamma(const double& x, std::ostream* pstream__ = nullptr)  
{
 return functions_only_namespace::test_lgamma(x, pstream__);
}


// [[stan::function]]
void test_lp(const double& a, double& lp__,
             stan::math::accumulator<double>& lp_accum__,
             std::ostream* pstream__ = nullptr)  
{
 functions_only_namespace::test_lp<false>(a, lp__, lp_accum__, pstream__);
}


// [[stan::function]]
auto test_rng(const double& a, boost::ecuyer1988& base_rng__,
              std::ostream* pstream__ = nullptr)  
{
 return functions_only_namespace::test_rng(a, base_rng__, pstream__);
}


// [[stan::function]]
auto test_lpdf(const double& a, const double& b,
               std::ostream* pstream__ = nullptr)  
{
 return functions_only_namespace::test_lpdf<false>(a, b, pstream__);
}


real my_log1p_exp(real x) {
  return log1p_exp(x);
}

real array_fun(array[] real a) {
  return sum(a);
}

real int_array_fun(array[] int a) {
  return sum(a);
}

vector my_vector_mul_by_5(vector x) {
  vector[num_elements(x)] result = x * 5.0;
  return result;
}

int int_only_multiplication(int a, int b) {
  return a * b;
}

real test_lgamma(real x) {
  return lgamma(x);
}

// test special functions
void test_lp(real a) {
  a ~ normal(0, 1);
}

real test_rng(real a) {
  return normal_rng(a, 1);
}

real test_lpdf(real a, real b) {
  return normal_lpdf(a | b, 1);
}
real my_log1p_exp(real x) {
  return log1p_exp(x);
}

real array_fun(array[] real a) {
  return sum(a);
}

real int_array_fun(array[] int a) {
  return sum(a);
}

vector my_vector_mul_by_5(vector x) {
  vector[num_elements(x)] result = x * 5.0;
  return result;
}

int int_only_multiplication(int a, int b) {
  return a * b;
}

real test_lgamma(real x) {
  return lgamma(x);
}

// test special functions
void test_lp(real a) {
  a ~ normal(0, 1);
}

real test_rng(real a) {
  return normal_rng(a, 1);
}

real test_lpdf(real a, real b) {
  return normal_lpdf(a | b, 1);
}
$ node info.js
{ "inputs": { "a": { "type": "int", "dimensions": 0},
              "b": { "type": "real", "dimensions": 0},
              "c": { "type": "real", "dimensions": 1},
              "d": { "type": "real", "dimensions": 1},
              "e": { "type": "real", "dimensions": 2},
              "f": { "type": "int", "dimensions": 1},
              "g": { "type": "real", "dimensions": 1},
              "h": { "type": "real", "dimensions": 2},
              "i": { "type": "real", "dimensions": 3},
              "j": { "type": "int", "dimensions": 3} },
  "parameters": { "l": { "type": "real", "dimensions": 1},
                  "m": { "type": "real", "dimensions": 1},
                  "n": { "type": "real", "dimensions": 1},
                  "o": { "type": "real", "dimensions": 1},
                  "p": { "type": "real", "dimensions": 2},
                  "q": { "type": "real", "dimensions": 2},
                  "r": { "type": "real", "dimensions": 2},
                  "s": { "type": "real", "dimensions": 2},
                  "y": { "type": "real", "dimensions": 0} },
  "transformed parameters": {  },
  "generated quantities": {  },
  "functions": [  ],
  "distributions": [  ],
  "included_files": [  ] }

$ node optimization.js
Semantic error in 'string', line 3, column 8 to column 11: 
Function is declared without specifying a definition.

$ node pedantic.js
["Warning in 'string', line 7, column 17: Argument 10000 suggests there may be parameters that are not unit scale; consider rescaling with a multiplier (see manual section 22.12).","Warning: The parameter k was declared but was not used in the density calculation."]
[]
["Warning in 'string', line 4, column 9: The variable tt may not have been assigned a value before its use."]
[]
$ node standalone-functions.js

$ node version.js
%%NAME%% %%VERSION%%
%%NAME%% %%VERSION%%
%%NAME%% %%VERSION%%
$ node warnings.js
["Warning in 'string', line 4, column 4: Comments beginning with # are deprecated. Please use // in place of # for line comments."]
