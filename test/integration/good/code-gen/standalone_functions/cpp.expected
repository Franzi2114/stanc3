  $ ../../../../../../install/default/bin/stanc --standalone_functions --print-cpp basic.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace basic_model_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'basic.stan', line 4, column 8 to column 28)",
                                                      " (in 'basic.stan', line 3, column 30 to line 5, column 5)",
                                                      " (in 'basic.stan', line 10, column 2 to column 43)",
                                                      " (in 'basic.stan', line 11, column 2 to column 16)",
                                                      " (in 'basic.stan', line 9, column 1 to line 12, column 2)",
                                                      " (in 'basic.stan', line 15, column 2 to column 13)",
                                                      " (in 'basic.stan', line 14, column 43 to line 16, column 2)"};


template <typename T0__>
typename boost::math::tools::promote_args<T0__>::type
my_log1p_exp(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = typename boost::math::tools::promote_args<T0__>::type;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    current_statement__ = 1;
    return log1p_exp(x);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct my_log1p_exp_functor__ {
template <typename T0__>
typename boost::math::tools::promote_args<T0__>::type
operator()(const T0__& x, std::ostream* pstream__)  const 
{
return my_log1p_exp(x, pstream__);
}
};

template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, -1, 1>
my_vector_mul_by_5(const Eigen::Matrix<T0__, -1, 1>& x,
                   std::ostream* pstream__) {
  using local_scalar_t__ = typename boost::math::tools::promote_args<T0__>::type;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    current_statement__ = 3;
    validate_non_negative_index("result", "num_elements(x)", num_elements(x));
    Eigen::Matrix<local_scalar_t__, -1, 1> result;
    result = Eigen::Matrix<local_scalar_t__, -1, 1>(num_elements(x));
    
    current_statement__ = 3;
    for (size_t sym1__ = 1; sym1__ <= num_elements(x); ++sym1__) {
      current_statement__ = 3;
      assign(result, cons_list(index_uni(sym1__), nil_index_list()),
        std::numeric_limits<double>::quiet_NaN(), "assigning variable result");
    }
    current_statement__ = 3;
    assign(result, nil_index_list(), multiply(x, 5.0),
      "assigning variable result");
    current_statement__ = 4;
    return result;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct my_vector_mul_by_5_functor__ {
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, -1, 1>
operator()(const Eigen::Matrix<T0__, -1, 1>& x, std::ostream* pstream__)  const 
{
return my_vector_mul_by_5(x, pstream__);
}
};

int
int_only_multiplication(const int& a, const int& b, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    current_statement__ = 6;
    return (a * b);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct int_only_multiplication_functor__ {
int
operator()(const int& a, const int& b, std::ostream* pstream__)  const 
{
return int_only_multiplication(a, b, pstream__);
}
};

}

  $ ../../../../../../install/default/bin/stanc --standalone_functions --print-cpp integrate.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace integrate_model_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'integrate.stan', line 4, column 4 to column 27)",
                                                      " (in 'integrate.stan', line 3, column 29 to line 5, column 3)",
                                                      " (in 'integrate.stan', line 8, column 4 to column 18)",
                                                      " (in 'integrate.stan', line 9, column 4 to column 22)",
                                                      " (in 'integrate.stan', line 10, column 4 to column 47)",
                                                      " (in 'integrate.stan', line 11, column 4 to column 18)",
                                                      " (in 'integrate.stan', line 7, column 78 to line 12, column 3)",
                                                      " (in 'integrate.stan', line 15, column 4 to column 15)",
                                                      " (in 'integrate.stan', line 21, column 4 to column 142)",
                                                      " (in 'integrate.stan', line 14, column 23 to line 22, column 3)"};


template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, -1, 1>
integrand(const Eigen::Matrix<T0__, -1, 1>& x, std::ostream* pstream__) {
  using local_scalar_t__ = typename boost::math::tools::promote_args<T0__>::type;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    current_statement__ = 1;
    return stan::math::exp(minus(square(x)));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct integrand_functor__ {
template <typename T0__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, -1, 1>
operator()(const Eigen::Matrix<T0__, -1, 1>& x, std::ostream* pstream__)  const 
{
return integrand(x, pstream__);
}
};

template <typename T0__, typename T1__, typename T2__, typename T3__>
std::vector<typename boost::math::tools::promote_args<T0__, T1__, T2__,
T3__>::type>
integrand_ode(const T0__& r, const std::vector<T1__>& f,
              const std::vector<T2__>& theta, const std::vector<T3__>& x_r,
              const std::vector<int>& x_i, std::ostream* pstream__) {
  using local_scalar_t__ = typename boost::math::tools::promote_args<T0__,
          T1__,
          T2__,
          T3__>::type;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    current_statement__ = 3;
    validate_non_negative_index("df_dx", "1", 1);
    std::vector<local_scalar_t__> df_dx;
    df_dx = std::vector<local_scalar_t__>(1, 0);
    
    local_scalar_t__ x;
    
    current_statement__ = 4;
    x = std::numeric_limits<double>::quiet_NaN();
    current_statement__ = 4;
    x = logit(r);
    current_statement__ = 5;
    assign(df_dx, cons_list(index_uni(1), nil_index_list()),
      ((stan::math::exp(-square(x)) * 1) / (r * (1 - r))),
      "assigning variable df_dx");
    current_statement__ = 6;
    return df_dx;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct integrand_ode_functor__ {
template <typename T0__, typename T1__, typename T2__, typename T3__>
std::vector<typename boost::math::tools::promote_args<T0__, T1__, T2__,
T3__>::type>
operator()(const T0__& r, const std::vector<T1__>& f,
           const std::vector<T2__>& theta, const std::vector<T3__>& x_r,
           const std::vector<int>& x_i, std::ostream* pstream__)  const 
{
return integrand_ode(r, f, theta, x_r, x_i, pstream__);
}
};

double
ode_integrate(std::ostream* pstream__) {
  using local_scalar_t__ = double;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    current_statement__ = 8;
    validate_non_negative_index("x_i", "0", 0);
    std::vector<int> x_i;
    x_i = std::vector<int>(0, 0);
    
    current_statement__ = 9;
    return integrate_ode_bdf(integrand_ode_functor__(), rep_array(0.0, 1), 1E-5,
  rep_array((1.0 - 1E-5), 1), rep_array(0.0, 0), rep_array(0.0, 0), x_i,
  pstream__)[
        (1 - 1)][(1 - 1)];
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct ode_integrate_functor__ {
double
operator()(std::ostream* pstream__)  const 
{
return ode_integrate(pstream__);
}
};

}

  $ ../../../../../../install/default/bin/stanc --standalone_functions --print-cpp lgamma.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace lgamma_model_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'lgamma.stan', line 4, column 8 to column 25)",
                                                      " (in 'lgamma.stan', line 3, column 29 to line 5, column 5)"};


template <typename T0__>
typename boost::math::tools::promote_args<T0__>::type
test_lgamma(const T0__& x, std::ostream* pstream__) {
  using local_scalar_t__ = typename boost::math::tools::promote_args<T0__>::type;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    current_statement__ = 1;
    return stan::math::lgamma(x);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct test_lgamma_functor__ {
template <typename T0__>
typename boost::math::tools::promote_args<T0__>::type
operator()(const T0__& x, std::ostream* pstream__)  const 
{
return test_lgamma(x, pstream__);
}
};

}

  $ ../../../../../../install/default/bin/stanc --standalone_functions --print-cpp special_functions.stan

// Code generated by %%NAME%% %%VERSION%%
#include <stan/model/model_header.hpp>
namespace special_functions_model_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using std::pow;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using stan::model::cons_list;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::nil_index_list;
using namespace stan::math; 

static int current_statement__ = 0;
static const std::vector<string> locations_array__ = {" (found before start of program)",
                                                      " (in 'special_functions.stan', line 4, column 4 to column 21)",
                                                      " (in 'special_functions.stan', line 3, column 23 to line 5, column 3)",
                                                      " (in 'special_functions.stan', line 8, column 4 to column 28)",
                                                      " (in 'special_functions.stan', line 7, column 24 to line 9, column 3)",
                                                      " (in 'special_functions.stan', line 12, column 4 to column 33)",
                                                      " (in 'special_functions.stan', line 11, column 33 to line 13, column 3)"};


template <bool propto__, typename T0__, typename T_lp__,
typename T_lp_accum__>
void
test_lp(const T0__& a, T_lp__& lp__, T_lp_accum__& lp_accum__,
        std::ostream* pstream__) {
  using local_scalar_t__ = typename boost::math::tools::promote_args<T0__>::type;
  
  try {
    current_statement__ = 1;
    lp_accum__.add(normal_log<propto__>(a, 0, 1));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct test_lp_functor__ {
template <bool propto__, typename T0__, typename T_lp__,
typename T_lp_accum__>
void
operator()(const T0__& a, T_lp__& lp__, T_lp_accum__& lp_accum__,
           std::ostream* pstream__)  const 
{
return test_lp(a, lp__, lp_accum__, pstream__);
}
};

template <typename T0__, typename RNG>
typename boost::math::tools::promote_args<T0__>::type
test_rng(const T0__& a, RNG& base_rng__, std::ostream* pstream__) {
  using local_scalar_t__ = typename boost::math::tools::promote_args<T0__>::type;
  const static bool propto__ = true;
  (void) propto__;
  
  try {
    current_statement__ = 3;
    return normal_rng(a, 1, base_rng__);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct test_rng_functor__ {
template <typename T0__, typename RNG>
typename boost::math::tools::promote_args<T0__>::type
operator()(const T0__& a, RNG& base_rng__, std::ostream* pstream__)  const 
{
return test_rng(a, base_rng__, pstream__);
}
};

template <bool propto__, typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__,
T1__>::type
test_lpdf(const T0__& a, const T1__& b, std::ostream* pstream__) {
  using local_scalar_t__ = typename boost::math::tools::promote_args<T0__,
          T1__>::type;
  
  try {
    current_statement__ = 5;
    return normal_lpdf<false>(a, b, 1);
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct test_lpdf_functor__ {
template <bool propto__, typename T0__, typename T1__>
typename boost::math::tools::promote_args<T0__,
T1__>::type
operator()(const T0__& a, const T1__& b, std::ostream* pstream__)  const 
{
return test_lpdf(a, b, pstream__);
}
};

}

