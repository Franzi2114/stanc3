Hello - from /home/enetsee/.vscode/extensions/jaredly.reason-vscode-1.5.2/bin.native.linux
Previous log location: /tmp/lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json", "globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{}}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/lib/Expression_gen.ml","languageId":"ocaml","version":1,"text":"open Core_kernel\nopen Mir\n\nlet ends_with suffix s = String.is_suffix ~suffix s\nlet starts_with prefix s = String.is_prefix ~prefix s\n\nlet functions_requiring_namespace =\n  Set.Poly.of_list\n    [ \"e\"; \"pi\"; \"log2\"; \"log10\"; \"sqrt2\"; \"not_a_number\"; \"positive_infinity\"\n    ; \"negative_infinity\"; \"machine_precision\"; \"abs\"; \"acos\"; \"acosh\"; \"asin\"\n    ; \"asinh\"; \"atan\"; \"atan2\"; \"atanh\"; \"cbrt\"; \"ceil\"; \"cos\"; \"cosh\"; \"erf\"\n    ; \"erfc\"; \"exp\"; \"exp2\"; \"expm1\"; \"fabs\"; \"floor\"; \"lgamma\"; \"log\"; \"log1p\"\n    ; \"log2\"; \"log10\"; \"round\"; \"sin\"; \"sinh\"; \"sqrt\"; \"tan\"; \"tanh\"; \"tgamma\"\n    ; \"trunc\"; \"fdim\"; \"fmax\"; \"fmin\"; \"hypot\"; \"fma\" ]\n\nlet contains_elt lst elt = List.mem lst elt ~equal:( = )\n\nlet stan_namespace_qualify f =\n  if Set.mem functions_requiring_namespace f then \"stan::math::\" ^ f else f\n\n(* return true if the types of the two expression are the same *)\nlet types_match e1 e2 = e1.texpr_type = e2.texpr_type\n\n(* \"__\" is an illegal suffix for user functions, used for built-in operators not in signatures *)\nlet is_user_defined f =\n  (not (Stan_math_signatures.is_stan_math_function_name f))\n  && (not (ends_with \"__\" f))\n  && not (starts_with \"stan::math::\" f)\n\n(* retun true if the tpe of the expression is integer or real *)\nlet is_scalar e = e.texpr_type = UInt || e.texpr_type = UReal\nlet is_matrix e = e.texpr_type = UMatrix\nlet is_row_vector e = e.texpr_type = URowVector\n\n(* stub *)\nlet pretty_print _e = \"pretty printed e\"\n\n(* stub *)\nlet rec gen_return_type = function\n  | Void -> \"void\"\n  | ReturnType rt -> gen_type_ut rt\n\n(* terrible quadratic implementation *)\nand gen_arg_types = function\n  | [] -> \"\"\n  | [(_adt, ut)] -> gen_type_ut ut\n  | (_adt, ut) :: ts -> sprintf \"%s, %s\" (gen_type_ut ut) (gen_arg_types ts)\n\nand gen_type_ut = function\n  | UInt -> \"int\"\n  | UReal -> \"local_scalar_t__\"\n  | UVector -> \"Eigen::Matrix<local_scalar_t, -1, 1>\"\n  | URowVector -> \"Eigen::Matrix<local_scalar_t, 1, -1>\"\n  | UMatrix -> \"Eigen::Matrix<local_scalar_t, -1, 1>\"\n  | UArray t -> sprintf \"std::vector<%s>\" (gen_type_ut t)\n  | UFun (args_t, return_t) ->\n      sprintf \"std::function<%s(%s)>\" (gen_return_type return_t)\n        (gen_arg_types args_t)\n  | UMathLibraryFunction -> \"std::function<void()>\"\n\nlet gen_type e = gen_type_ut e.texpr_type\n\nlet suffix_args f =\n  if ends_with \"_rng\" f then [\"base_rng__\"]\n  else if ends_with \"_lp\" f then [\"lp__\"; \"lp_accum__\"]\n  else []\n\nlet user_defined_args f = if is_user_defined f then [\"pstream__\"] else []\n\nlet gen_extra_fun_args f =\n  String.concat ~sep:\", \" (List.append (suffix_args f) (user_defined_args f))\n\nlet include_sep s1 s2 = String.length s1 > 0 && String.length s2 > 0\n\nlet gen_sep s1 s2 =\n  sprintf \"%s%s%s\" s1 (if include_sep s1 s2 then \", \" else \"\") s2\n\nlet rec gen_exprs = function\n  | [] -> \"\"\n  | [hd] -> gen_expr hd\n  | hd :: tl -> sprintf \"%s, %s\" (gen_expr hd) (gen_exprs tl)\n\nand gen_index = function\n  | All -> \"stan::model::index_omni()\"\n  | Single e -> sprintf \"stan::model::index_uni(%s)\" (gen_expr e)\n  | Upfrom e -> sprintf \"stan::model::index_min(%s)\" (gen_expr e)\n  | Downfrom e -> sprintf \"stan::model::index_max(%s)\" (gen_expr e)\n  | Between (e_low, e_high) ->\n      sprintf \"stan::model::index_min_max(%s, %s)\" (gen_expr e_low)\n        (gen_expr e_high)\n  | MultiIndex e -> sprintf \"stan::model::index_multi(%s)\" (gen_expr e)\n\nand gen_indexes = function\n  | [] -> \"stan::model::nil_index_list()\"\n  | idx :: idxs ->\n      sprintf \"stan::model::cons_list(%s, %s)\" (gen_index idx)\n        (gen_indexes idxs)\n\nand gen_short_circuit_logical_op op es =\n  sprintf \"(stan::math::value(%s) %s stan::math::value(%s))\"\n    (gen_expr (List.nth_exn es 0))\n    op\n    (gen_expr (List.nth_exn es 1))\n\nand gen_unary fm es = sprintf fm (gen_expr (List.hd_exn es))\nand gen_binary fm es = sprintf fm (gen_expr (first es)) (gen_expr (second es))\nand first es = List.nth_exn es 0\nand second es = List.nth_exn es 1\n\nand gen_scalar_binary scalar_fmt generic_fmt es =\n  gen_binary\n    ( if is_scalar (first es) && is_scalar (second es) then scalar_fmt\n    else generic_fmt )\n    es\n\n(* assumes everything well formed from parser checks *)\nand gen_fun_app f es =\n  match f with\n  | \"And\" -> gen_short_circuit_logical_op \"&&\" es\n  | \"Or\" -> gen_short_circuit_logical_op \"||\" es\n  | \"PMinus\" ->\n      gen_unary (if is_scalar (List.hd_exn es) then \"-%s\" else \"minus(%s)\") es\n  | \"PPlus\" -> gen_unary \"%s\" es\n  | \"Transpose\" ->\n      gen_unary\n        (if is_scalar (List.hd_exn es) then \"transpose(%s)\" else \"%s\")\n        es\n  | \"PNot\" -> gen_unary \"logial_negation(%s)\" es\n  | \"Minus\" -> gen_scalar_binary \"(%s - %s)\" \"subtract(%s, %s)\" es\n  | \"Plus\" -> gen_scalar_binary \"(%s + %s)\" \"add(%s, %s)\" es\n  | \"Times\" -> gen_scalar_binary \"(%s * %s)\" \"multiply(%s, %s)\" es\n  | \"Divide\" ->\n      if\n        is_matrix (second es)\n        && (is_matrix (first es) || is_row_vector (first es))\n      then gen_binary \"mdivide_right(%s, %s)\" es\n      else gen_scalar_binary \"(%s / %s)\" \"divide(%s, %s)\" es\n  | \"Modulo\" -> gen_binary \"modulus(%s, %s)\" es\n  | \"LDivide\" -> gen_binary \"mdivide_left(%s, %s)\" es\n  | \"EltTimes\" -> gen_scalar_binary \"(%s * %s)\" \"elt_multiply(%s, %s)\" es\n  | \"EltDivide\" -> gen_scalar_binary \"(%s / %s)\" \"elt_divide(%s, %s)\" es\n  | \"Pow\" -> gen_binary \"pow(%s, %s)\" es\n  | \"Equals\" -> gen_binary \"logical_eq(%s, %s)\" es\n  | \"NEquals\" -> gen_binary \"logical_neq(%s, %s)\" es\n  | \"Less\" -> gen_binary \"logical_lt(%s, %s)\" es\n  | \"Leq\" -> gen_binary \"logical_lte(%s, %s)\" es\n  | \"Greater\" -> gen_binary \"logical_gt(%s, %s)\" es\n  | \"Geq\" -> gen_binary \"logical_gte(%s, %s)\" es\n  | \"lmultiply\" -> gen_binary \"multiply_log(%s, %s)\" es\n  | \"lchoose\" -> gen_binary \"binomial_coefficient_log(%s, %s)\" es\n  | \"target\" -> \"get_lp(lp__, lp_accum__)\"\n  | \"get_lp\" -> \"get_lp(lp__, lp_accum__)\"\n  | \"max\" ->\n      if List.length es = 2 then gen_binary \"std::max(%s, %s)\" es\n      else gen_ordinary_function f es\n  | \"min\" ->\n      if List.length es = 2 then gen_binary \"std::min(%s, %s)\" es\n      else gen_ordinary_function f es\n  | \"ceil\" ->\n      if is_scalar (first es) then gen_unary \"std::ceil(%s)\" es\n      else gen_ordinary_function f es\n  | _ -> gen_ordinary_function (stan_namespace_qualify f) es\n\nand gen_ordinary_function f es =\n  sprintf \"%s(%s)\" f (gen_sep (gen_exprs es) (gen_extra_fun_args f))\n\nand gen_expr (e : expr_typed_located) =\n  match e.texpr with\n  | Var s -> s\n  | Lit (Str, s) -> sprintf \"%S\" s\n  | Lit (_, s) -> s\n  | FunApp (f, es) -> gen_fun_app f es\n  | TernaryIf (ec, et, ef) ->\n      if types_match et ef then\n        sprintf \"(%s ? %s : %s)\" (gen_expr ec) (gen_expr et) (gen_expr ef)\n      else\n        sprintf\n          \"(%s ? stan::math::promote_scalar<%s>(%s) : \\\n           stan::math::promote_scalar<%s>(%s)\"\n          (gen_expr ec) (gen_type e) (gen_expr et) (gen_type e) (gen_expr ef)\n  | Indexed (e, idx) ->\n      sprintf \"stan::model::rvalue(%s, %s, %S)\" (gen_expr e) (gen_indexes idx)\n        (pretty_print e)\n\nlet%expect_test \"endswith1\" =\n  printf \"%B\" (ends_with \"\" \"\") ;\n  [%expect {| true |}]\n\nlet%expect_test \"endswith2\" =\n  printf \"%B\" (ends_with \"\" \"a\") ;\n  [%expect {| true |}]\n\nlet%expect_test \"endswith3\" =\n  printf \"%B\" (ends_with \"b\" \"\") ;\n  [%expect {| false |}]\n\nlet%expect_test \"endswith4\" =\n  printf \"%B\" (ends_with \"c\" \"c\") ;\n  [%expect {| true |}]\n\nlet%expect_test \"endswith5\" =\n  printf \"%B\" (ends_with \"_rng\" \"foo_rng\") ;\n  [%expect {| true |}]\n\nlet%expect_test \"endswith5\" =\n  printf \"%B\" (ends_with \"_rng\" \"_r\") ;\n  [%expect {| false |}]\n\n(* these functions are just for testing *)\nlet dummy_locate e =\n  {texpr= e; texpr_type= UInt; texpr_adlevel= DataOnly; texpr_loc= no_span}\n\nlet gen_unlocated e = gen_expr (dummy_locate e)\n\nlet%expect_test \"gen_expr1\" =\n  printf \"%s\" (gen_unlocated (Var \"a\")) ;\n  [%expect {| a |}]\n\nlet%expect_test \"gen_expr2\" =\n  printf \"%s\" (gen_unlocated (Lit (Str, \"b\"))) ;\n  [%expect {| \"b\" |}]\n\nlet%expect_test \"gen_expr3\" =\n  printf \"%s\" (gen_unlocated (Lit (Int, \"112\"))) ;\n  [%expect {| 112 |}]\n\nlet%expect_test \"gen_expr4\" =\n  printf \"%s\" (gen_unlocated (Lit (Int, \"112\"))) ;\n  [%expect {| 112 |}]\n\nlet%expect_test \"gen_expr5\" =\n  printf \"%s\" (gen_unlocated (FunApp (\"pi\", []))) ;\n  [%expect {| stan::math::pi() |}]\n\nlet%expect_test \"gen_expr6\" =\n  printf \"%s\"\n    (gen_unlocated (FunApp (\"sqrt\", [dummy_locate (Lit (Int, \"123\"))]))) ;\n  [%expect {| stan::math::sqrt(123) |}]\n\nlet%expect_test \"gen_expr7\" =\n  printf \"%s\"\n    (gen_unlocated\n       (FunApp\n          ( \"atan2\"\n          , [dummy_locate (Lit (Int, \"123\")); dummy_locate (Lit (Real, \"1.2\"))]\n          ))) ;\n  [%expect {| stan::math::atan2(123, 1.2) |}]\n\nlet%expect_test \"gen_expr9\" =\n  printf \"%s\"\n    (gen_unlocated\n       (TernaryIf\n          ( dummy_locate (Lit (Int, \"1\"))\n          , dummy_locate (Lit (Real, \"1.2\"))\n          , dummy_locate (Lit (Real, \"2.3\")) ))) ;\n  [%expect {| (1 ? 1.2 : 2.3) |}]\n\nlet%expect_test \"gen_expr10\" =\n  printf \"%s\" (gen_unlocated (Indexed (dummy_locate (Var \"a\"), [All]))) ;\n  [%expect\n    {| stan::model::rvalue(a, stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()), \"pretty printed e\") |}]\n\nlet%expect_test \"gen_expr11\" =\n  printf \"%s\"\n    (gen_unlocated (FunApp (\"poisson_rng\", [dummy_locate (Lit (Int, \"123\"))]))) ;\n  [%expect {| poisson_rng(123, base_rng__) |}]\n"}}}
Found a `dune` file at /home/enetsee/Workspace/enetsee/stanc3/lib
]] Making a new jbuilder package at /home/enetsee/Workspace/enetsee/stanc3/lib
=== Project root: /home/enetsee/Workspace/enetsee/stanc3
Detected `opam` dependency manager for local use
=== Build dir:    /home/enetsee/Workspace/enetsee/stanc3/_build
Get ocaml stdlib dirs
Include subdirs? no :/
Got a compiled base /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Debugging.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Debugging.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Semantic_check.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Semantic_check.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Preprocessor.mli
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Preprocessor.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Util.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Util.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Ast_to_Mir.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Ast_to_Mir.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Stan_math_code_gen.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Stan_math_code_gen.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Type_conversion.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Type_conversion.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Peep.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Peep.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Symbol_table.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Symbol_table.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Operators.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Operators.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Errors.mli
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Errors.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Type_conversion.mli
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Type_conversion.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Ast_to_Mir.mli
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Ast_to_Mir.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Symbol_table.mli
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Symbol_table.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Pretty_printing.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Pretty_printing.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Stan_math_signatures.mli
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Stan_math_signatures.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Optimize.mli
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Optimize.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Preprocessor.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Preprocessor.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Mir.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Mir.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Errors.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Errors.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Operators.mli
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Operators.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Expression_gen.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Expression_gen.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Optimize.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Optimize.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Ast.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Ast.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Parse.mli
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Parse.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Parse.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Parse.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Semantic_check.mli
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Semantic_check.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/lib/Stan_math_signatures.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs/stanclib__Stan_math_signatures.cmt
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/variantslib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/uchar
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/typerep
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/stdio
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/splittable_random
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/sexplib0
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/sexplib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/result
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_sexp_conv/runtime-lib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_inline_test/runtime-lib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_inline_test/config
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_hash/runtime-lib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/config
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/common
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/collector
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_deriving
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_compare/runtime-lib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_bench/runtime-lib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_assert/runtime-lib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/parsexp
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ocaml
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/menhirLib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/jane-street-headers
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/fmt
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/fieldslib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/core_kernel/base_for_tests
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/core_kernel
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/bin_prot/shape
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/bin_prot
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/shadow_stdlib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/md5
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/caml
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ocaml
Depedency dirs /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/variantslib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/uchar /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/typerep /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/stdio /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/splittable_random /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/sexplib0 /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/sexplib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/result /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_sexp_conv/runtime-lib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_inline_test/runtime-lib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_inline_test/config /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_hash/runtime-lib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/config /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/common /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/collector /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_deriving /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_compare/runtime-lib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_bench/runtime-lib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_assert/runtime-lib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/parsexp /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ocaml /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/menhirLib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/jane-street-headers /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/fmt /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/fieldslib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/core_kernel/base_for_tests /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/core_kernel /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/bin_prot/shape /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/bin_prot /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/shadow_stdlib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/md5 /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/caml /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ocaml
>> Build system running: opam exec -- dune build @install --root .
>>> stdout

>>> stderr

Affected files: 
Cleaning bsconfig.json
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/enetsee/Workspace/enetsee/stanc3/lib/bsconfig.json", "diagnostics": []}}
Read message 
{"jsonrpc":"2.0","id":1,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/lib/Expression_gen.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00810623168945ms
➡️ running bsc /home/enetsee/Workspace/enetsee/stanc3/_opam/bin/ocamlopt.opt -c -I '/home/enetsee/Workspace/enetsee/stanc3/_build/default/lib/.stanclib.objs' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/variantslib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/uchar' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/typerep' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/stdio' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/splittable_random' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/sexplib0' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/sexplib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/result' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_sexp_conv/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_inline_test/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_inline_test/config' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_hash/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/config' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/common' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/collector' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_deriving' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_compare/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_bench/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_assert/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/parsexp' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ocaml' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/menhirLib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/jane-street-headers' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/fmt' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/fieldslib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/core_kernel/base_for_tests' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/core_kernel' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/bin_prot/shape' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/bin_prot' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/shadow_stdlib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/md5' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/caml' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ocaml' -bin-annot -open Stanclib -w @a-4-29-40-41-42-44-45-48-58-59-60-40 -strict-sequence -strict-formats -short-paths -keep-locs -g -ppx '/home/enetsee/Workspace/enetsee/stanc3/_build/default/.ppx/0dbe217fe1eb2a8d779ac5e4daea1a6b/ppx.exe --as-ppx --cookie '\''library-name="stanclib"'\''' -impl /home/enetsee/Workspace/enetsee/stanc3/_build/.lsp/stanclib__Expression_gen.ast with pwd /home/enetsee/Workspace/enetsee/stanc3/lib
<< Making lastDefinitions with type error for file:///home/enetsee/Workspace/enetsee/stanc3/lib/Expression_gen.ml
Sending response {"id": 1, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: ", "command": ""}}]}
Running diagnostics for file:///home/enetsee/Workspace/enetsee/stanc3/lib/Expression_gen.ml
type error here File "command line", line 1:
Error: Unbound module Stanclib
Hint: Did you mean Stdlib?
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/enetsee/Workspace/enetsee/stanc3/lib/Expression_gen.ml", "diagnostics": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "message": "File \"command line\", line 1:\nError: Unbound module Stanclib\nHint: Did you mean Stdlib?", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/lib/Expression_gen.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Expression_gen.ml","languageId":"ocaml","version":1,"text":"open Core_kernel\nopen Mir\n\nlet ends_with suffix s = String.is_suffix ~suffix s\nlet starts_with prefix s = String.is_prefix ~prefix s\n\nlet functions_requiring_namespace =\n  Set.Poly.of_list\n    [ \"e\"; \"pi\"; \"log2\"; \"log10\"; \"sqrt2\"; \"not_a_number\"; \"positive_infinity\"\n    ; \"negative_infinity\"; \"machine_precision\"; \"abs\"; \"acos\"; \"acosh\"; \"asin\"\n    ; \"asinh\"; \"atan\"; \"atan2\"; \"atanh\"; \"cbrt\"; \"ceil\"; \"cos\"; \"cosh\"; \"erf\"\n    ; \"erfc\"; \"exp\"; \"exp2\"; \"expm1\"; \"fabs\"; \"floor\"; \"lgamma\"; \"log\"; \"log1p\"\n    ; \"log2\"; \"log10\"; \"round\"; \"sin\"; \"sinh\"; \"sqrt\"; \"tan\"; \"tanh\"; \"tgamma\"\n    ; \"trunc\"; \"fdim\"; \"fmax\"; \"fmin\"; \"hypot\"; \"fma\" ]\n\nlet contains_elt lst elt = List.mem lst elt ~equal:( = )\n\nlet stan_namespace_qualify f =\n  if Set.mem functions_requiring_namespace f then \"stan::math::\" ^ f else f\n\n(* return true if the types of the two expression are the same *)\nlet types_match e1 e2 = e1.texpr_type = e2.texpr_type\n\n(* \"__\" is an illegal suffix for user functions, used for built-in operators not in signatures *)\nlet is_user_defined f =\n  (not (Stan_math_signatures.is_stan_math_function_name f))\n  && (not (ends_with \"__\" f))\n  && not (starts_with \"stan::math::\" f)\n\n(* retun true if the tpe of the expression is integer or real *)\nlet is_scalar e = e.texpr_type = UInt || e.texpr_type = UReal\nlet is_matrix e = e.texpr_type = UMatrix\nlet is_row_vector e = e.texpr_type = URowVector\n\n(* stub *)\nlet pretty_print _e = \"pretty printed e\"\n\n(* stub *)\nlet rec gen_return_type = function\n  | Void -> \"void\"\n  | ReturnType rt -> gen_type_ut rt\n\n(* terrible quadratic implementation *)\nand gen_arg_types = function\n  | [] -> \"\"\n  | [(_adt, ut)] -> gen_type_ut ut\n  | (_adt, ut) :: ts -> sprintf \"%s, %s\" (gen_type_ut ut) (gen_arg_types ts)\n\nand gen_type_ut = function\n  | UInt -> \"int\"\n  | UReal -> \"local_scalar_t__\"\n  | UVector -> \"Eigen::Matrix<local_scalar_t, -1, 1>\"\n  | URowVector -> \"Eigen::Matrix<local_scalar_t, 1, -1>\"\n  | UMatrix -> \"Eigen::Matrix<local_scalar_t, -1, 1>\"\n  | UArray t -> sprintf \"std::vector<%s>\" (gen_type_ut t)\n  | UFun (args_t, return_t) ->\n      sprintf \"std::function<%s(%s)>\" (gen_return_type return_t)\n        (gen_arg_types args_t)\n  | UMathLibraryFunction -> \"std::function<void()>\"\n\nlet gen_type e = gen_type_ut e.texpr_type\n\nlet suffix_args f =\n  if ends_with \"_rng\" f then [\"base_rng__\"]\n  else if ends_with \"_lp\" f then [\"lp__\"; \"lp_accum__\"]\n  else []\n\nlet user_defined_args f = if is_user_defined f then [\"pstream__\"] else []\n\nlet gen_extra_fun_args f =\n  String.concat ~sep:\", \" (List.append (suffix_args f) (user_defined_args f))\n\nlet include_sep s1 s2 = String.length s1 > 0 && String.length s2 > 0\n\nlet gen_sep s1 s2 =\n  sprintf \"%s%s%s\" s1 (if include_sep s1 s2 then \", \" else \"\") s2\n\nlet rec gen_exprs = function\n  | [] -> \"\"\n  | [hd] -> gen_expr hd\n  | hd :: tl -> sprintf \"%s, %s\" (gen_expr hd) (gen_exprs tl)\n\nand gen_index = function\n  | All -> \"stan::model::index_omni()\"\n  | Single e -> sprintf \"stan::model::index_uni(%s)\" (gen_expr e)\n  | Upfrom e -> sprintf \"stan::model::index_min(%s)\" (gen_expr e)\n  | Downfrom e -> sprintf \"stan::model::index_max(%s)\" (gen_expr e)\n  | Between (e_low, e_high) ->\n      sprintf \"stan::model::index_min_max(%s, %s)\" (gen_expr e_low)\n        (gen_expr e_high)\n  | MultiIndex e -> sprintf \"stan::model::index_multi(%s)\" (gen_expr e)\n\nand gen_indexes = function\n  | [] -> \"stan::model::nil_index_list()\"\n  | idx :: idxs ->\n      sprintf \"stan::model::cons_list(%s, %s)\" (gen_index idx)\n        (gen_indexes idxs)\n\nand gen_short_circuit_logical_op op es =\n  sprintf \"(stan::math::value(%s) %s stan::math::value(%s))\"\n    (gen_expr (List.nth_exn es 0))\n    op\n    (gen_expr (List.nth_exn es 1))\n\nand gen_unary fm es = sprintf fm (gen_expr (List.hd_exn es))\nand gen_binary fm es = sprintf fm (gen_expr (first es)) (gen_expr (second es))\nand first es = List.nth_exn es 0\nand second es = List.nth_exn es 1\n\nand gen_scalar_binary scalar_fmt generic_fmt es =\n  gen_binary\n    ( if is_scalar (first es) && is_scalar (second es) then scalar_fmt\n    else generic_fmt )\n    es\n\n(* assumes everything well formed from parser checks *)\nand gen_fun_app f es =\n  match f with\n  | \"And\" -> gen_short_circuit_logical_op \"&&\" es\n  | \"Or\" -> gen_short_circuit_logical_op \"||\" es\n  | \"PMinus\" ->\n      gen_unary (if is_scalar (List.hd_exn es) then \"-%s\" else \"minus(%s)\") es\n  | \"PPlus\" -> gen_unary \"%s\" es\n  | \"Transpose\" ->\n      gen_unary\n        (if is_scalar (List.hd_exn es) then \"transpose(%s)\" else \"%s\")\n        es\n  | \"PNot\" -> gen_unary \"logial_negation(%s)\" es\n  | \"Minus\" -> gen_scalar_binary \"(%s - %s)\" \"subtract(%s, %s)\" es\n  | \"Plus\" -> gen_scalar_binary \"(%s + %s)\" \"add(%s, %s)\" es\n  | \"Times\" -> gen_scalar_binary \"(%s * %s)\" \"multiply(%s, %s)\" es\n  | \"Divide\" ->\n      if\n        is_matrix (second es)\n        && (is_matrix (first es) || is_row_vector (first es))\n      then gen_binary \"mdivide_right(%s, %s)\" es\n      else gen_scalar_binary \"(%s / %s)\" \"divide(%s, %s)\" es\n  | \"Modulo\" -> gen_binary \"modulus(%s, %s)\" es\n  | \"LDivide\" -> gen_binary \"mdivide_left(%s, %s)\" es\n  | \"EltTimes\" -> gen_scalar_binary \"(%s * %s)\" \"elt_multiply(%s, %s)\" es\n  | \"EltDivide\" -> gen_scalar_binary \"(%s / %s)\" \"elt_divide(%s, %s)\" es\n  | \"Pow\" -> gen_binary \"pow(%s, %s)\" es\n  | \"Equals\" -> gen_binary \"logical_eq(%s, %s)\" es\n  | \"NEquals\" -> gen_binary \"logical_neq(%s, %s)\" es\n  | \"Less\" -> gen_binary \"logical_lt(%s, %s)\" es\n  | \"Leq\" -> gen_binary \"logical_lte(%s, %s)\" es\n  | \"Greater\" -> gen_binary \"logical_gt(%s, %s)\" es\n  | \"Geq\" -> gen_binary \"logical_gte(%s, %s)\" es\n  | \"lmultiply\" -> gen_binary \"multiply_log(%s, %s)\" es\n  | \"lchoose\" -> gen_binary \"binomial_coefficient_log(%s, %s)\" es\n  | \"target\" -> \"get_lp(lp__, lp_accum__)\"\n  | \"get_lp\" -> \"get_lp(lp__, lp_accum__)\"\n  | \"max\" ->\n      if List.length es = 2 then gen_binary \"std::max(%s, %s)\" es\n      else gen_ordinary_function f es\n  | \"min\" ->\n      if List.length es = 2 then gen_binary \"std::min(%s, %s)\" es\n      else gen_ordinary_function f es\n  | \"ceil\" ->\n      if is_scalar (first es) then gen_unary \"std::ceil(%s)\" es\n      else gen_ordinary_function f es\n  | _ -> gen_ordinary_function (stan_namespace_qualify f) es\n\nand gen_ordinary_function f es =\n  sprintf \"%s(%s)\" f (gen_sep (gen_exprs es) (gen_extra_fun_args f))\n\nand gen_expr (e : expr_typed_located) =\n  match e.texpr with\n  | Var s -> s\n  | Lit (Str, s) -> sprintf \"%S\" s\n  | Lit (_, s) -> s\n  | FunApp (f, es) -> gen_fun_app f es\n  | TernaryIf (ec, et, ef) ->\n      if types_match et ef then\n        sprintf \"(%s ? %s : %s)\" (gen_expr ec) (gen_expr et) (gen_expr ef)\n      else\n        sprintf\n          \"(%s ? stan::math::promote_scalar<%s>(%s) : \\\n           stan::math::promote_scalar<%s>(%s)\"\n          (gen_expr ec) (gen_type e) (gen_expr et) (gen_type e) (gen_expr ef)\n  | Indexed (e, idx) ->\n      sprintf \"stan::model::rvalue(%s, %s, %S)\" (gen_expr e) (gen_indexes idx)\n        (pretty_print e)\n\nlet%expect_test \"endswith1\" =\n  printf \"%B\" (ends_with \"\" \"\") ;\n  [%expect {| true |}]\n\nlet%expect_test \"endswith2\" =\n  printf \"%B\" (ends_with \"\" \"a\") ;\n  [%expect {| true |}]\n\nlet%expect_test \"endswith3\" =\n  printf \"%B\" (ends_with \"b\" \"\") ;\n  [%expect {| false |}]\n\nlet%expect_test \"endswith4\" =\n  printf \"%B\" (ends_with \"c\" \"c\") ;\n  [%expect {| true |}]\n\nlet%expect_test \"endswith5\" =\n  printf \"%B\" (ends_with \"_rng\" \"foo_rng\") ;\n  [%expect {| true |}]\n\nlet%expect_test \"endswith5\" =\n  printf \"%B\" (ends_with \"_rng\" \"_r\") ;\n  [%expect {| false |}]\n\n(* these functions are just for testing *)\nlet dummy_locate e =\n  {texpr= e; texpr_type= UInt; texpr_adlevel= DataOnly; texpr_loc= no_span}\n\nlet gen_unlocated e = gen_expr (dummy_locate e)\n\nlet%expect_test \"gen_expr1\" =\n  printf \"%s\" (gen_unlocated (Var \"a\")) ;\n  [%expect {| a |}]\n\nlet%expect_test \"gen_expr2\" =\n  printf \"%s\" (gen_unlocated (Lit (Str, \"b\"))) ;\n  [%expect {| \"b\" |}]\n\nlet%expect_test \"gen_expr3\" =\n  printf \"%s\" (gen_unlocated (Lit (Int, \"112\"))) ;\n  [%expect {| 112 |}]\n\nlet%expect_test \"gen_expr4\" =\n  printf \"%s\" (gen_unlocated (Lit (Int, \"112\"))) ;\n  [%expect {| 112 |}]\n\nlet%expect_test \"gen_expr5\" =\n  printf \"%s\" (gen_unlocated (FunApp (\"pi\", []))) ;\n  [%expect {| stan::math::pi() |}]\n\nlet%expect_test \"gen_expr6\" =\n  printf \"%s\"\n    (gen_unlocated (FunApp (\"sqrt\", [dummy_locate (Lit (Int, \"123\"))]))) ;\n  [%expect {| stan::math::sqrt(123) |}]\n\nlet%expect_test \"gen_expr7\" =\n  printf \"%s\"\n    (gen_unlocated\n       (FunApp\n          ( \"atan2\"\n          , [dummy_locate (Lit (Int, \"123\")); dummy_locate (Lit (Real, \"1.2\"))]\n          ))) ;\n  [%expect {| stan::math::atan2(123, 1.2) |}]\n\nlet%expect_test \"gen_expr9\" =\n  printf \"%s\"\n    (gen_unlocated\n       (TernaryIf\n          ( dummy_locate (Lit (Int, \"1\"))\n          , dummy_locate (Lit (Real, \"1.2\"))\n          , dummy_locate (Lit (Real, \"2.3\")) ))) ;\n  [%expect {| (1 ? 1.2 : 2.3) |}]\n\nlet%expect_test \"gen_expr10\" =\n  printf \"%s\" (gen_unlocated (Indexed (dummy_locate (Var \"a\"), [All]))) ;\n  [%expect\n    {| stan::model::rvalue(a, stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list()), \"pretty printed e\") |}]\n\nlet%expect_test \"gen_expr11\" =\n  printf \"%s\"\n    (gen_unlocated (FunApp (\"poisson_rng\", [dummy_locate (Lit (Int, \"123\"))]))) ;\n  [%expect {| poisson_rng(123, base_rng__) |}]\n"}}}
Found a `dune` file at /home/enetsee/Workspace/enetsee/stanc3/src/lib
]] Making a new jbuilder package at /home/enetsee/Workspace/enetsee/stanc3/src/lib
=== Project root: /home/enetsee/Workspace/enetsee/stanc3
Detected `opam` dependency manager for local use
=== Build dir:    /home/enetsee/Workspace/enetsee/stanc3/_build
Get ocaml stdlib dirs
Include subdirs? no :/
Got a compiled base /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Debugging.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Debugging.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Semantic_check.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Semantic_check.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Preprocessor.mli
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Preprocessor.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Util.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Util.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Ast_to_Mir.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Ast_to_Mir.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Stan_math_code_gen.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Stan_math_code_gen.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Type_conversion.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Type_conversion.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Peep.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Peep.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Symbol_table.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Symbol_table.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Operators.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Operators.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Errors.mli
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Errors.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Type_conversion.mli
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Type_conversion.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Ast_to_Mir.mli
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Ast_to_Mir.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Symbol_table.mli
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Symbol_table.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Pretty_printing.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Pretty_printing.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Stan_math_signatures.mli
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Stan_math_signatures.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Optimize.mli
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Optimize.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Preprocessor.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Preprocessor.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Mir.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Mir.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Errors.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Errors.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Operators.mli
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Operators.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Expression_gen.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Expression_gen.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Optimize.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Optimize.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Ast.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Ast.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Parse.mli
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Parse.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Parse.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Parse.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Semantic_check.mli
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Semantic_check.cmt
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/lib/Stan_math_signatures.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs/stanclib__Stan_math_signatures.cmt
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/variantslib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/uchar
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/typerep
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/stdio
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/splittable_random
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/sexplib0
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/sexplib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/result
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_sexp_conv/runtime-lib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_inline_test/runtime-lib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_inline_test/config
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_hash/runtime-lib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/config
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/common
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/collector
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_deriving
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_compare/runtime-lib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_bench/runtime-lib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_assert/runtime-lib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/parsexp
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ocaml
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/menhirLib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/jane-street-headers
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/fmt
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/fieldslib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/core_kernel/base_for_tests
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/core_kernel
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/bin_prot/shape
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/bin_prot
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/shadow_stdlib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/md5
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/caml
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ocaml
Depedency dirs /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/variantslib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/uchar /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/typerep /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/stdio /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/splittable_random /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/sexplib0 /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/sexplib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/result /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_sexp_conv/runtime-lib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_inline_test/runtime-lib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_inline_test/config /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_hash/runtime-lib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/config /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/common /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/collector /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_deriving /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_compare/runtime-lib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_bench/runtime-lib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_assert/runtime-lib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/parsexp /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ocaml /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/menhirLib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/jane-street-headers /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/fmt /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/fieldslib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/core_kernel/base_for_tests /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/core_kernel /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/bin_prot/shape /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/bin_prot /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/shadow_stdlib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/md5 /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/caml /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ocaml
>> Build system running: opam exec -- dune build @install --root .
>>> stdout

>>> stderr
      menhir src/lib/parsing_errors.ml
Read 455 sample input sentences and 455 error messages.
Affected files: 
Cleaning bsconfig.json
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/bsconfig.json", "diagnostics": []}}
Running diagnostics for file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Expression_gen.ml
➡️ running bsc /home/enetsee/Workspace/enetsee/stanc3/_opam/bin/ocamlopt.opt -c -I '/home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/variantslib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/uchar' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/typerep' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/stdio' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/splittable_random' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/sexplib0' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/sexplib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/result' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_sexp_conv/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_inline_test/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_inline_test/config' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_hash/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/config' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/common' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/collector' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_deriving' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_compare/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_bench/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_assert/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/parsexp' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ocaml' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/menhirLib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/jane-street-headers' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/fmt' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/fieldslib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/core_kernel/base_for_tests' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/core_kernel' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/bin_prot/shape' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/bin_prot' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/shadow_stdlib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/md5' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/caml' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ocaml' -bin-annot -open Stanclib -w @a-4-29-40-41-42-44-45-48-58-59-60-40 -strict-sequence -strict-formats -short-paths -keep-locs -g -ppx '/home/enetsee/Workspace/enetsee/stanc3/_build/default/.ppx/0dbe217fe1eb2a8d779ac5e4daea1a6b/ppx.exe --as-ppx --cookie '\''library-name="stanclib"'\''' -impl /home/enetsee/Workspace/enetsee/stanc3/_build/.lsp/stanclib__Expression_gen.ast with pwd /home/enetsee/Workspace/enetsee/stanc3/src/lib
<< Making lastDefinitions with type error for file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Expression_gen.ml
type error here File "command line", line 1:
Error: Unbound module Stanclib
Hint: Did you mean Stdlib?
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Expression_gen.ml", "diagnostics": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "message": "File \"command line\", line 1:\nError: Unbound module Stanclib\nHint: Did you mean Stdlib?", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":2,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Expression_gen.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00190734863281ms
Sending response {"id": 2, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":3,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Expression_gen.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Sending response {"id": 3, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: ", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeWatchedFiles","params":{"changes":[{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/.merlin","type":1},{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/lib/.merlin","type":3}]}}
Got a watched file change
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeWatchedFiles","params":{"changes":[{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.merlin","type":1},{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/_build/default/.merlin","type":2},{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/.merlin","type":2},{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/.merlin","type":2}]}}
Got a watched file change
Read message 
{"jsonrpc":"2.0","id":4,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Expression_gen.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[{"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"message":"File \"command line\", line 1:\nError: Unbound module Stanclib\nHint: Did you mean Stdlib?","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00786781311035ms
Sending response {"id": 4, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":5,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Expression_gen.ml"},"position":{"line":6,"character":8}}}
[server] Got a method textDocument/hover
[server] processing took 0.0109672546387ms
Sending response {"id": 5, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":6,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Expression_gen.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[{"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"message":"File \"command line\", line 1:\nError: Unbound module Stanclib\nHint: Did you mean Stdlib?","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00286102294922ms
Sending response {"id": 6, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":7,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Expression_gen.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0171661376953ms
Sending response {"id": 7, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: ", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Mir.ml","languageId":"ocaml","version":1,"text":"(** The Middle Intermediate Representation, which program transformations\n    operate on *)\n\nopen Core_kernel\n\n(*\n   XXX Missing:\n   * TODO? foreach loops - matrix vs array (fine because of get_base1?)\n   * TODO during optimization:\n       - mark for loops with known bounds\n       - mark FnApps as containing print or reject\n*)\n\n(** Source code locations *)\ntype location =\n  { filename: string\n  ; line_num: int\n  ; col_num: int\n  ; included_from: location option }\n\n(** Delimited locations *)\ntype location_span = {begin_loc: location; end_loc: location}\n\nlet merge_spans left right = {begin_loc= left.begin_loc; end_loc= right.end_loc}\n\n(** Unsized types for function arguments and for decorating expressions\n    during type checking; we have a separate type here for Math library\n    functions as these functions can be overloaded, so do not have a unique\n    type in the usual sense. Still, we want to assign a unique type to every\n    expression during type checking.  *)\ntype unsizedtype =\n  | UInt\n  | UReal\n  | UVector\n  | URowVector\n  | UMatrix\n  | UArray of unsizedtype\n  | UFun of (autodifftype * unsizedtype) list * returntype\n  | UMathLibraryFunction\n[@@deriving sexp, hash]\n\n(** Flags for data only arguments to functions *)\nand autodifftype = DataOnly | AutoDiffable [@@deriving sexp, hash, compare]\n\nand returntype = Void | ReturnType of unsizedtype [@@deriving sexp, hash]\n\n(** Sized types, for variable declarations *)\ntype 'e sizedtype =\n  | SInt\n  | SReal\n  | SVector of 'e\n  | SRowVector of 'e\n  | SMatrix of 'e * 'e\n  | SArray of 'e sizedtype * 'e\n[@@deriving sexp, compare, map, hash]\n\n(** remove_size [st] discards size information from a sizedtype\n    to return an unsizedtype. *)\nlet rec remove_size = function\n  | SInt -> UInt\n  | SReal -> UReal\n  | SVector _ -> UVector\n  | SRowVector _ -> URowVector\n  | SMatrix _ -> UMatrix\n  | SArray (t, _) -> UArray (remove_size t)\n\ntype litType = Int | Real | Str [@@deriving sexp, hash]\n\ntype 'e index =\n  | All\n  | Single of 'e\n  (*\n  | MatrixSingle of 'e\n *)\n  | Upfrom of 'e\n  | Downfrom of 'e\n  | Between of 'e * 'e\n  | MultiIndex of 'e\n[@@deriving sexp, hash, map]\n\n(** XXX\n*)\ntype 'e expr =\n  | Var of string\n  | Lit of litType * string\n  | FunApp of string * 'e list\n  | TernaryIf of 'e * 'e * 'e\n  (* XXX And and Or nodes*)\n  | Indexed of 'e * 'e index list\n[@@deriving sexp, hash, map]\n\n(* This directive silences some spurious warnings from ppx_deriving *)\n[@@@ocaml.warning \"-A\"]\n\ntype fun_arg_decl = (autodifftype * string * unsizedtype) list\n\nand ('e, 's) statement =\n  | Assignment of 'e * 'e\n  | TargetPE of 'e\n  | NRFunApp of string * 'e list\n  | Break\n  | Continue\n  | Return of 'e option\n  | Skip\n  | IfElse of 'e * 's * 's option\n  | While of 'e * 's\n  (* XXX Collapse with For? *)\n  | For of {loopvar: string; lower: 'e; upper: 'e; body: 's}\n  (* A Block for now corresponds tightly with a C++ block:\n     variables declared within it have local scope and are garbage collected\n     when the block ends.*)\n  | Block of 's list\n  (* An SList does not share any of Block's semantics - it is just multiple\n     (ordered!) statements*)\n  | SList of 's list\n  | Decl of\n      { decl_adtype: autodifftype\n      ; decl_id: string\n      ; decl_type: 'e sizedtype }\n  | FunDef of\n      { fdrt: unsizedtype option\n      ; fdname: string\n      ; fdargs: fun_arg_decl\n      ; fdbody: 's }\n[@@deriving sexp, hash, map]\n\ntype io_block =\n  | Data\n  | Parameters\n  | TransformedParameters\n  | GeneratedQuantities\n[@@deriving sexp, hash]\n\ntype 'e io_var = string * ('e sizedtype * io_block) [@@deriving sexp]\n\ntype ('e, 's) prog =\n  { functions_block: 's list\n  ; input_vars: 'e io_var list\n  ; prepare_data: 's list (* data & transformed data decls and statements *)\n  ; prepare_params: 's list (* param & tparam decls and statements *)\n  ; log_prob: 's list (*assumes data & params are in scope and ready*)\n  ; generate_quantities: 's list (* assumes data & params ready & in scope*)\n  ; transform_inits: 's list\n  ; output_vars: 'e io_var list\n  ; prog_name: string\n  ; prog_path: string }\n[@@deriving sexp]\n\ntype expr_typed_located =\n  { texpr_type: unsizedtype\n  ; texpr_loc: location_span sexp_opaque [@compare.ignore]\n  ; texpr: expr_typed_located expr\n  ; texpr_adlevel: autodifftype }\n[@@deriving sexp, hash, map, of_sexp]\n\ntype stmt_loc =\n  { sloc: location_span sexp_opaque [@compare.ignore]\n  ; stmt: (expr_typed_located, stmt_loc) statement }\n[@@deriving hash, map, sexp, of_sexp]\n\ntype typed_prog = (expr_typed_located, stmt_loc) prog [@@deriving sexp]\n\n(* == Pretty printers ======================================================= *)\n\nlet pp_builtin_syntax = Fmt.(string |> styled `Yellow)\nlet pp_keyword = Fmt.(string |> styled `Blue)\nlet angle_brackets pp_v ppf v = Fmt.pf ppf \"@[<1><%a>@]\" pp_v v\nlet label str pp_v ppf v = Fmt.pf ppf \"%s=%a\" str pp_v v\n\nlet pp_autodifftype ppf = function\n  | DataOnly -> pp_keyword ppf \"data \"\n  | AutoDiffable -> ()\n\nlet rec pp_unsizedtype ppf = function\n  | UInt -> pp_keyword ppf \"int\"\n  | UReal -> pp_keyword ppf \"real\"\n  | UVector -> pp_keyword ppf \"vector\"\n  | URowVector -> pp_keyword ppf \"row_vector\"\n  | UMatrix -> pp_keyword ppf \"matrix\"\n  | UArray ut -> (Fmt.brackets pp_unsizedtype) ppf ut\n  | UFun (argtypes, rt) ->\n      Fmt.pf ppf {|%a => %a|}\n        Fmt.(list (pair ~sep:comma pp_autodifftype pp_unsizedtype) ~sep:comma)\n        argtypes pp_returntype rt\n  | UMathLibraryFunction ->\n      (angle_brackets Fmt.string) ppf \"Stan Math function\"\n\nand pp_returntype ppf = function\n  | Void -> Fmt.string ppf \"void\"\n  | ReturnType ut -> pp_unsizedtype ppf ut\n\nlet rec pp_sizedtype pp_e ppf st =\n  match st with\n  | SInt -> Fmt.string ppf \"int\"\n  | SReal -> Fmt.string ppf \"real\"\n  | SVector expr -> Fmt.pf ppf {|vector%a|} (Fmt.brackets pp_e) expr\n  | SRowVector expr -> Fmt.pf ppf {|row_vector%a|} (Fmt.brackets pp_e) expr\n  | SMatrix (d1_expr, d2_expr) ->\n      Fmt.pf ppf {|matrix%a|}\n        Fmt.(pair ~sep:comma pp_e pp_e |> brackets)\n        (d1_expr, d2_expr)\n  | SArray (st, expr) ->\n      Fmt.pf ppf {|array%a|}\n        Fmt.(\n          pair ~sep:comma (fun ppf st -> pp_sizedtype pp_e ppf st) pp_e\n          |> brackets)\n        (st, expr)\n\nlet rec pp_expr pp_e ppf = function\n  | Var varname -> Fmt.string ppf varname\n  | Lit (Str, str) -> Fmt.pf ppf \"%S\" str\n  | Lit (_, str) -> Fmt.string ppf str\n  | FunApp (name, args) ->\n      Fmt.string ppf name ;\n      Fmt.(list pp_e ~sep:Fmt.comma |> parens) ppf args\n  | TernaryIf (pred, texpr, fexpr) ->\n      Fmt.pf ppf {|@[%a@ %a@,%a@,%a@ %a@]|} pp_e pred pp_builtin_syntax \"?\"\n        pp_e texpr pp_builtin_syntax \":\" pp_e fexpr\n  | Indexed (expr, indices) ->\n      Fmt.pf ppf {|@[%a%a@]|} pp_e expr\n        Fmt.(list (pp_index pp_e) ~sep:comma |> brackets)\n        indices\n\nand pp_index pp_e ppf = function\n  | All -> Fmt.char ppf ':'\n  | Single index -> pp_e ppf index\n  | Upfrom index -> Fmt.pf ppf {|%a:|} pp_e index\n  | Downfrom index -> Fmt.pf ppf {|:%a|} pp_e index\n  | Between (lower, upper) -> Fmt.pf ppf {|%a:%a|} pp_e lower pp_e upper\n  | MultiIndex index -> Fmt.pf ppf {|%a|} pp_e index\n\nlet pp_fun_arg_decl ppf (autodifftype, name, unsizedtype) =\n  Fmt.pf ppf \"%a%a %s\" pp_autodifftype autodifftype pp_unsizedtype unsizedtype\n    name\n\nlet rec pp_statement pp_e pp_s ppf = function\n  | Assignment (assignee, expr) ->\n      Fmt.pf ppf {|@[<h>%a :=@ %a;@]|} pp_e assignee pp_e expr\n  | TargetPE expr ->\n      Fmt.pf ppf {|@[<h>%a +=@ %a;@]|} pp_keyword \"target\" pp_e expr\n  | NRFunApp (name, args) ->\n      Fmt.pf ppf {|@[%s%a;@]|} name Fmt.(list pp_e ~sep:comma |> parens) args\n  | Break -> pp_keyword ppf \"break;\"\n  | Continue -> pp_keyword ppf \"continue;\"\n  | Skip -> pp_keyword ppf \"skip;\"\n  | Return (Some expr) -> Fmt.pf ppf {|%a %a;|} pp_keyword \"return\" pp_e expr\n  | Return _ -> pp_keyword ppf \"return;\"\n  | IfElse (pred, s_true, Some s_false) ->\n      Fmt.pf ppf {|@[<v2>@[%a(%a)@] {@;%a@]@;@[<v2>@[} %a@] {@;%a@]@;}|}\n        pp_builtin_syntax \"if\" pp_e pred pp_s s_true pp_builtin_syntax \"else\"\n        pp_s s_false\n  | IfElse (pred, s_true, _) ->\n      Fmt.pf ppf {|@[<v2>@[%a(%a)@] {@;%a@]@;}|} pp_builtin_syntax \"if\" pp_e\n        pred pp_s s_true\n  | While (pred, stmt) ->\n      Fmt.pf ppf {|@[<v2>@[%a(%a)@] {@;%a@]@;}|} pp_builtin_syntax \"while\" pp_e\n        pred pp_s stmt\n  | For {loopvar; lower; upper; body} ->\n      Fmt.pf ppf {|@[<v2>@[%a(%s in %a:%a)@] {@;%a@]@;}|} pp_builtin_syntax\n        \"for\" loopvar pp_e lower pp_e upper pp_s body\n  | Block stmts -> Fmt.pf ppf {|@[<v>%a@]|} Fmt.(list pp_s ~sep:Fmt.cut) stmts\n  | SList stmts -> Fmt.(list pp_s ~sep:Fmt.cut |> vbox) ppf stmts\n  | Decl {decl_adtype; decl_id; decl_type} ->\n      Fmt.pf ppf {|%a%a %s;|} pp_autodifftype decl_adtype (pp_sizedtype pp_e)\n        decl_type decl_id\n  | FunDef {fdrt; fdname; fdargs; fdbody} -> (\n    match fdrt with\n    | Some rt ->\n        Fmt.pf ppf {|@[<v2>%a %s%a {@ %a@]@ }|} pp_unsizedtype rt fdname\n          Fmt.(list pp_fun_arg_decl ~sep:comma |> parens)\n          fdargs pp_s fdbody\n    | None ->\n        Fmt.pf ppf {|@[<v2>%s %s%a {@ %a@]@ }|} \"void\" fdname\n          Fmt.(list pp_fun_arg_decl ~sep:comma |> parens)\n          fdargs pp_s fdbody )\n\nlet pp_io_block ppf = function\n  | Data -> Fmt.string ppf \"data\"\n  | Parameters -> Fmt.string ppf \"parameters\"\n  | TransformedParameters -> Fmt.string ppf \"transformed_parameters\"\n  | GeneratedQuantities -> Fmt.string ppf \"generated_quantities\"\n\nlet pp_io_var pp_e ppf (name, (sized_ty, io_block)) =\n  Fmt.pf ppf \"@[<h>%a %a %s;@]\" pp_io_block io_block (pp_sizedtype pp_e)\n    sized_ty name\n\nlet pp_block label pp_elem ppf elems =\n  Fmt.pf ppf {|@[<v2>%a {@ %a@]@ }|} pp_keyword label\n    Fmt.(list ~sep:cut pp_elem)\n    elems ;\n  Format.pp_force_newline ppf ()\n\nlet pp_io_var_block label pp_e = pp_block label (pp_io_var pp_e)\n\nlet pp_input_vars pp_e ppf {input_vars; _} =\n  pp_io_var_block \"input_vars\" pp_e ppf input_vars\n\nlet pp_output_vars pp_e ppf {output_vars; _} =\n  pp_io_var_block \"output_vars\" pp_e ppf output_vars\n\nlet pp_functions_block pp_s ppf {functions_block; _} =\n  pp_block \"functions\" pp_s ppf functions_block\n\nlet pp_prepare_data pp_s ppf {prepare_data; _} =\n  pp_block \"prepare_data\" pp_s ppf prepare_data\n\nlet pp_prepare_params pp_s ppf {prepare_params; _} =\n  pp_block \"prepare_params\" pp_s ppf prepare_params\n\nlet pp_log_prob pp_s ppf {log_prob; _} = pp_block \"log_prob\" pp_s ppf log_prob\n\nlet pp_generate_quantities pp_s ppf {generate_quantities; _} =\n  pp_block \"generate_quantities\" pp_s ppf generate_quantities\n\nlet pp_transform_inits pp_s ppf {transform_inits; _} =\n  pp_block \"transform_inits\" pp_s ppf transform_inits\n\nlet pp_prog pp_e pp_s ppf prog =\n  Format.open_vbox 0 ;\n  pp_functions_block pp_s ppf prog ;\n  Fmt.cut ppf () ;\n  pp_input_vars pp_e ppf prog ;\n  Fmt.cut ppf () ;\n  pp_prepare_data pp_s ppf prog ;\n  Fmt.cut ppf () ;\n  pp_prepare_params pp_s ppf prog ;\n  Fmt.cut ppf () ;\n  pp_log_prob pp_s ppf prog ;\n  Fmt.cut ppf () ;\n  pp_generate_quantities pp_s ppf prog ;\n  Fmt.cut ppf () ;\n  pp_transform_inits pp_s ppf prog ;\n  Fmt.cut ppf () ;\n  pp_output_vars pp_e ppf prog ;\n  Format.close_box ()\n\nlet rec pp_expr_typed_located ppf {texpr; _} =\n  pp_expr pp_expr_typed_located ppf texpr\n\nlet rec pp_stmt_loc ppf {stmt; _} =\n  pp_statement pp_expr_typed_located pp_stmt_loc ppf stmt\n\nlet rec sexp_of_expr_typed_located {texpr; _} =\n  sexp_of_expr sexp_of_expr_typed_located texpr\n\nlet rec sexp_of_stmt_loc {stmt; _} =\n  match stmt with\n  | SList ls -> sexp_of_list sexp_of_stmt_loc ls\n  | s -> sexp_of_statement sexp_of_expr_typed_located sexp_of_stmt_loc s\n\nlet pp_typed_prog ppf prog = pp_prog pp_expr_typed_located pp_stmt_loc ppf prog\n\n(* ===================== Some helper functions and values ====================== *)\nlet no_loc = {filename= \"\"; line_num= 0; col_num= 0; included_from= None}\nlet no_span = {begin_loc= no_loc; end_loc= no_loc}\n\nlet internal_expr =\n  { texpr= Var \"UHOH\"\n  ; texpr_loc= no_span\n  ; texpr_type= UInt\n  ; texpr_adlevel= DataOnly }\n\nlet zero = {internal_expr with texpr= Lit (Int, \"0\"); texpr_type= UInt}\n\n(* Internal function names *)\nlet fn_length = \"Length__\"\nlet fn_make_array = \"MakeArray__\"\nlet fn_make_rowvec = \"MakeRowVec__\"\nlet fn_negative_infinity = \"NegativeInfinity__\"\nlet fn_read_data = \"ReadData__\"\nlet fn_read_param = \"ReadParam__\"\nlet fn_constrain = \"Constrain__\"\nlet fn_unconstrain = \"Unconstrain__\"\nlet fn_check = \"Check__\"\nlet fn_print = \"Print__\"\nlet fn_reject = \"Reject__\"\n"}}}
Read message 
{"jsonrpc":"2.0","id":8,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Mir.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
➡️ running bsc /home/enetsee/Workspace/enetsee/stanc3/_opam/bin/ocamlopt.opt -c -I '/home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/variantslib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/uchar' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/typerep' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/stdio' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/splittable_random' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/sexplib0' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/sexplib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/result' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_sexp_conv/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_inline_test/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_inline_test/config' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_hash/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/config' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/common' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/collector' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_deriving' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_compare/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_bench/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_assert/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/parsexp' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ocaml' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/menhirLib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/jane-street-headers' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/fmt' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/fieldslib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/core_kernel/base_for_tests' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/core_kernel' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/bin_prot/shape' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/bin_prot' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/shadow_stdlib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/md5' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/caml' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ocaml' -bin-annot -open Stanclib -w @a-4-29-40-41-42-44-45-48-58-59-60-40 -strict-sequence -strict-formats -short-paths -keep-locs -g -ppx '/home/enetsee/Workspace/enetsee/stanc3/_build/default/.ppx/0dbe217fe1eb2a8d779ac5e4daea1a6b/ppx.exe --as-ppx --cookie '\''library-name="stanclib"'\''' -impl /home/enetsee/Workspace/enetsee/stanc3/_build/.lsp/stanclib__Mir.ast with pwd /home/enetsee/Workspace/enetsee/stanc3/src/lib
<< Making lastDefinitions with type error for file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Mir.ml
Sending response {"id": 8, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":9,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Mir.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00286102294922ms
Sending response {"id": 9, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: ", "command": ""}}]}
Running diagnostics for file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Mir.ml
type error here File "command line", line 1:
Error: Unbound module Stanclib
Hint: Did you mean Stdlib?
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Mir.ml", "diagnostics": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "message": "File \"command line\", line 1:\nError: Unbound module Stanclib\nHint: Did you mean Stdlib?", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":10,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Mir.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[{"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"message":"File \"command line\", line 1:\nError: Unbound module Stanclib\nHint: Did you mean Stdlib?","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 10, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Mir.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/mir/Mir.ml","languageId":"ocaml","version":1,"text":"(** The Middle Intermediate Representation, which program transformations\n    operate on *)\n\nopen Core_kernel\n\n(*\n   XXX Missing:\n   * TODO? foreach loops - matrix vs array (fine because of get_base1?)\n   * TODO during optimization:\n       - mark for loops with known bounds\n       - mark FnApps as containing print or reject\n*)\n\n(** Source code locations *)\ntype location =\n  { filename: string\n  ; line_num: int\n  ; col_num: int\n  ; included_from: location option }\n\n(** Delimited locations *)\ntype location_span = {begin_loc: location; end_loc: location}\n\nlet merge_spans left right = {begin_loc= left.begin_loc; end_loc= right.end_loc}\n\n(** Unsized types for function arguments and for decorating expressions\n    during type checking; we have a separate type here for Math library\n    functions as these functions can be overloaded, so do not have a unique\n    type in the usual sense. Still, we want to assign a unique type to every\n    expression during type checking.  *)\ntype unsizedtype =\n  | UInt\n  | UReal\n  | UVector\n  | URowVector\n  | UMatrix\n  | UArray of unsizedtype\n  | UFun of (autodifftype * unsizedtype) list * returntype\n  | UMathLibraryFunction\n[@@deriving sexp, hash]\n\n(** Flags for data only arguments to functions *)\nand autodifftype = DataOnly | AutoDiffable [@@deriving sexp, hash, compare]\n\nand returntype = Void | ReturnType of unsizedtype [@@deriving sexp, hash]\n\n(** Sized types, for variable declarations *)\ntype 'e sizedtype =\n  | SInt\n  | SReal\n  | SVector of 'e\n  | SRowVector of 'e\n  | SMatrix of 'e * 'e\n  | SArray of 'e sizedtype * 'e\n[@@deriving sexp, compare, map, hash]\n\n(** remove_size [st] discards size information from a sizedtype\n    to return an unsizedtype. *)\nlet rec remove_size = function\n  | SInt -> UInt\n  | SReal -> UReal\n  | SVector _ -> UVector\n  | SRowVector _ -> URowVector\n  | SMatrix _ -> UMatrix\n  | SArray (t, _) -> UArray (remove_size t)\n\ntype litType = Int | Real | Str [@@deriving sexp, hash]\n\ntype 'e index =\n  | All\n  | Single of 'e\n  (*\n  | MatrixSingle of 'e\n *)\n  | Upfrom of 'e\n  | Downfrom of 'e\n  | Between of 'e * 'e\n  | MultiIndex of 'e\n[@@deriving sexp, hash, map]\n\n(** XXX\n*)\ntype 'e expr =\n  | Var of string\n  | Lit of litType * string\n  | FunApp of string * 'e list\n  | TernaryIf of 'e * 'e * 'e\n  (* XXX And and Or nodes*)\n  | Indexed of 'e * 'e index list\n[@@deriving sexp, hash, map]\n\n(* This directive silences some spurious warnings from ppx_deriving *)\n[@@@ocaml.warning \"-A\"]\n\ntype fun_arg_decl = (autodifftype * string * unsizedtype) list\n\nand ('e, 's) statement =\n  | Assignment of 'e * 'e\n  | TargetPE of 'e\n  | NRFunApp of string * 'e list\n  | Break\n  | Continue\n  | Return of 'e option\n  | Skip\n  | IfElse of 'e * 's * 's option\n  | While of 'e * 's\n  (* XXX Collapse with For? *)\n  | For of {loopvar: string; lower: 'e; upper: 'e; body: 's}\n  (* A Block for now corresponds tightly with a C++ block:\n     variables declared within it have local scope and are garbage collected\n     when the block ends.*)\n  | Block of 's list\n  (* An SList does not share any of Block's semantics - it is just multiple\n     (ordered!) statements*)\n  | SList of 's list\n  | Decl of\n      { decl_adtype: autodifftype\n      ; decl_id: string\n      ; decl_type: 'e sizedtype }\n  | FunDef of\n      { fdrt: unsizedtype option\n      ; fdname: string\n      ; fdargs: fun_arg_decl\n      ; fdbody: 's }\n[@@deriving sexp, hash, map]\n\ntype io_block =\n  | Data\n  | Parameters\n  | TransformedParameters\n  | GeneratedQuantities\n[@@deriving sexp, hash]\n\ntype 'e io_var = string * ('e sizedtype * io_block) [@@deriving sexp]\n\ntype ('e, 's) prog =\n  { functions_block: 's list\n  ; input_vars: 'e io_var list\n  ; prepare_data: 's list (* data & transformed data decls and statements *)\n  ; prepare_params: 's list (* param & tparam decls and statements *)\n  ; log_prob: 's list (*assumes data & params are in scope and ready*)\n  ; generate_quantities: 's list (* assumes data & params ready & in scope*)\n  ; transform_inits: 's list\n  ; output_vars: 'e io_var list\n  ; prog_name: string\n  ; prog_path: string }\n[@@deriving sexp]\n\ntype expr_typed_located =\n  { texpr_type: unsizedtype\n  ; texpr_loc: location_span sexp_opaque [@compare.ignore]\n  ; texpr: expr_typed_located expr\n  ; texpr_adlevel: autodifftype }\n[@@deriving sexp, hash, map, of_sexp]\n\ntype stmt_loc =\n  { sloc: location_span sexp_opaque [@compare.ignore]\n  ; stmt: (expr_typed_located, stmt_loc) statement }\n[@@deriving hash, map, sexp, of_sexp]\n\ntype typed_prog = (expr_typed_located, stmt_loc) prog [@@deriving sexp]\n\n(* == Pretty printers ======================================================= *)\n\nlet pp_builtin_syntax = Fmt.(string |> styled `Yellow)\nlet pp_keyword = Fmt.(string |> styled `Blue)\nlet angle_brackets pp_v ppf v = Fmt.pf ppf \"@[<1><%a>@]\" pp_v v\nlet label str pp_v ppf v = Fmt.pf ppf \"%s=%a\" str pp_v v\n\nlet pp_autodifftype ppf = function\n  | DataOnly -> pp_keyword ppf \"data \"\n  | AutoDiffable -> ()\n\nlet rec pp_unsizedtype ppf = function\n  | UInt -> pp_keyword ppf \"int\"\n  | UReal -> pp_keyword ppf \"real\"\n  | UVector -> pp_keyword ppf \"vector\"\n  | URowVector -> pp_keyword ppf \"row_vector\"\n  | UMatrix -> pp_keyword ppf \"matrix\"\n  | UArray ut -> (Fmt.brackets pp_unsizedtype) ppf ut\n  | UFun (argtypes, rt) ->\n      Fmt.pf ppf {|%a => %a|}\n        Fmt.(list (pair ~sep:comma pp_autodifftype pp_unsizedtype) ~sep:comma)\n        argtypes pp_returntype rt\n  | UMathLibraryFunction ->\n      (angle_brackets Fmt.string) ppf \"Stan Math function\"\n\nand pp_returntype ppf = function\n  | Void -> Fmt.string ppf \"void\"\n  | ReturnType ut -> pp_unsizedtype ppf ut\n\nlet rec pp_sizedtype pp_e ppf st =\n  match st with\n  | SInt -> Fmt.string ppf \"int\"\n  | SReal -> Fmt.string ppf \"real\"\n  | SVector expr -> Fmt.pf ppf {|vector%a|} (Fmt.brackets pp_e) expr\n  | SRowVector expr -> Fmt.pf ppf {|row_vector%a|} (Fmt.brackets pp_e) expr\n  | SMatrix (d1_expr, d2_expr) ->\n      Fmt.pf ppf {|matrix%a|}\n        Fmt.(pair ~sep:comma pp_e pp_e |> brackets)\n        (d1_expr, d2_expr)\n  | SArray (st, expr) ->\n      Fmt.pf ppf {|array%a|}\n        Fmt.(\n          pair ~sep:comma (fun ppf st -> pp_sizedtype pp_e ppf st) pp_e\n          |> brackets)\n        (st, expr)\n\nlet rec pp_expr pp_e ppf = function\n  | Var varname -> Fmt.string ppf varname\n  | Lit (Str, str) -> Fmt.pf ppf \"%S\" str\n  | Lit (_, str) -> Fmt.string ppf str\n  | FunApp (name, args) ->\n      Fmt.string ppf name ;\n      Fmt.(list pp_e ~sep:Fmt.comma |> parens) ppf args\n  | TernaryIf (pred, texpr, fexpr) ->\n      Fmt.pf ppf {|@[%a@ %a@,%a@,%a@ %a@]|} pp_e pred pp_builtin_syntax \"?\"\n        pp_e texpr pp_builtin_syntax \":\" pp_e fexpr\n  | Indexed (expr, indices) ->\n      Fmt.pf ppf {|@[%a%a@]|} pp_e expr\n        Fmt.(list (pp_index pp_e) ~sep:comma |> brackets)\n        indices\n\nand pp_index pp_e ppf = function\n  | All -> Fmt.char ppf ':'\n  | Single index -> pp_e ppf index\n  | Upfrom index -> Fmt.pf ppf {|%a:|} pp_e index\n  | Downfrom index -> Fmt.pf ppf {|:%a|} pp_e index\n  | Between (lower, upper) -> Fmt.pf ppf {|%a:%a|} pp_e lower pp_e upper\n  | MultiIndex index -> Fmt.pf ppf {|%a|} pp_e index\n\nlet pp_fun_arg_decl ppf (autodifftype, name, unsizedtype) =\n  Fmt.pf ppf \"%a%a %s\" pp_autodifftype autodifftype pp_unsizedtype unsizedtype\n    name\n\nlet rec pp_statement pp_e pp_s ppf = function\n  | Assignment (assignee, expr) ->\n      Fmt.pf ppf {|@[<h>%a :=@ %a;@]|} pp_e assignee pp_e expr\n  | TargetPE expr ->\n      Fmt.pf ppf {|@[<h>%a +=@ %a;@]|} pp_keyword \"target\" pp_e expr\n  | NRFunApp (name, args) ->\n      Fmt.pf ppf {|@[%s%a;@]|} name Fmt.(list pp_e ~sep:comma |> parens) args\n  | Break -> pp_keyword ppf \"break;\"\n  | Continue -> pp_keyword ppf \"continue;\"\n  | Skip -> pp_keyword ppf \"skip;\"\n  | Return (Some expr) -> Fmt.pf ppf {|%a %a;|} pp_keyword \"return\" pp_e expr\n  | Return _ -> pp_keyword ppf \"return;\"\n  | IfElse (pred, s_true, Some s_false) ->\n      Fmt.pf ppf {|@[<v2>@[%a(%a)@] {@;%a@]@;@[<v2>@[} %a@] {@;%a@]@;}|}\n        pp_builtin_syntax \"if\" pp_e pred pp_s s_true pp_builtin_syntax \"else\"\n        pp_s s_false\n  | IfElse (pred, s_true, _) ->\n      Fmt.pf ppf {|@[<v2>@[%a(%a)@] {@;%a@]@;}|} pp_builtin_syntax \"if\" pp_e\n        pred pp_s s_true\n  | While (pred, stmt) ->\n      Fmt.pf ppf {|@[<v2>@[%a(%a)@] {@;%a@]@;}|} pp_builtin_syntax \"while\" pp_e\n        pred pp_s stmt\n  | For {loopvar; lower; upper; body} ->\n      Fmt.pf ppf {|@[<v2>@[%a(%s in %a:%a)@] {@;%a@]@;}|} pp_builtin_syntax\n        \"for\" loopvar pp_e lower pp_e upper pp_s body\n  | Block stmts -> Fmt.pf ppf {|@[<v>%a@]|} Fmt.(list pp_s ~sep:Fmt.cut) stmts\n  | SList stmts -> Fmt.(list pp_s ~sep:Fmt.cut |> vbox) ppf stmts\n  | Decl {decl_adtype; decl_id; decl_type} ->\n      Fmt.pf ppf {|%a%a %s;|} pp_autodifftype decl_adtype (pp_sizedtype pp_e)\n        decl_type decl_id\n  | FunDef {fdrt; fdname; fdargs; fdbody} -> (\n    match fdrt with\n    | Some rt ->\n        Fmt.pf ppf {|@[<v2>%a %s%a {@ %a@]@ }|} pp_unsizedtype rt fdname\n          Fmt.(list pp_fun_arg_decl ~sep:comma |> parens)\n          fdargs pp_s fdbody\n    | None ->\n        Fmt.pf ppf {|@[<v2>%s %s%a {@ %a@]@ }|} \"void\" fdname\n          Fmt.(list pp_fun_arg_decl ~sep:comma |> parens)\n          fdargs pp_s fdbody )\n\nlet pp_io_block ppf = function\n  | Data -> Fmt.string ppf \"data\"\n  | Parameters -> Fmt.string ppf \"parameters\"\n  | TransformedParameters -> Fmt.string ppf \"transformed_parameters\"\n  | GeneratedQuantities -> Fmt.string ppf \"generated_quantities\"\n\nlet pp_io_var pp_e ppf (name, (sized_ty, io_block)) =\n  Fmt.pf ppf \"@[<h>%a %a %s;@]\" pp_io_block io_block (pp_sizedtype pp_e)\n    sized_ty name\n\nlet pp_block label pp_elem ppf elems =\n  Fmt.pf ppf {|@[<v2>%a {@ %a@]@ }|} pp_keyword label\n    Fmt.(list ~sep:cut pp_elem)\n    elems ;\n  Format.pp_force_newline ppf ()\n\nlet pp_io_var_block label pp_e = pp_block label (pp_io_var pp_e)\n\nlet pp_input_vars pp_e ppf {input_vars; _} =\n  pp_io_var_block \"input_vars\" pp_e ppf input_vars\n\nlet pp_output_vars pp_e ppf {output_vars; _} =\n  pp_io_var_block \"output_vars\" pp_e ppf output_vars\n\nlet pp_functions_block pp_s ppf {functions_block; _} =\n  pp_block \"functions\" pp_s ppf functions_block\n\nlet pp_prepare_data pp_s ppf {prepare_data; _} =\n  pp_block \"prepare_data\" pp_s ppf prepare_data\n\nlet pp_prepare_params pp_s ppf {prepare_params; _} =\n  pp_block \"prepare_params\" pp_s ppf prepare_params\n\nlet pp_log_prob pp_s ppf {log_prob; _} = pp_block \"log_prob\" pp_s ppf log_prob\n\nlet pp_generate_quantities pp_s ppf {generate_quantities; _} =\n  pp_block \"generate_quantities\" pp_s ppf generate_quantities\n\nlet pp_transform_inits pp_s ppf {transform_inits; _} =\n  pp_block \"transform_inits\" pp_s ppf transform_inits\n\nlet pp_prog pp_e pp_s ppf prog =\n  Format.open_vbox 0 ;\n  pp_functions_block pp_s ppf prog ;\n  Fmt.cut ppf () ;\n  pp_input_vars pp_e ppf prog ;\n  Fmt.cut ppf () ;\n  pp_prepare_data pp_s ppf prog ;\n  Fmt.cut ppf () ;\n  pp_prepare_params pp_s ppf prog ;\n  Fmt.cut ppf () ;\n  pp_log_prob pp_s ppf prog ;\n  Fmt.cut ppf () ;\n  pp_generate_quantities pp_s ppf prog ;\n  Fmt.cut ppf () ;\n  pp_transform_inits pp_s ppf prog ;\n  Fmt.cut ppf () ;\n  pp_output_vars pp_e ppf prog ;\n  Format.close_box ()\n\nlet rec pp_expr_typed_located ppf {texpr; _} =\n  pp_expr pp_expr_typed_located ppf texpr\n\nlet rec pp_stmt_loc ppf {stmt; _} =\n  pp_statement pp_expr_typed_located pp_stmt_loc ppf stmt\n\nlet rec sexp_of_expr_typed_located {texpr; _} =\n  sexp_of_expr sexp_of_expr_typed_located texpr\n\nlet rec sexp_of_stmt_loc {stmt; _} =\n  match stmt with\n  | SList ls -> sexp_of_list sexp_of_stmt_loc ls\n  | s -> sexp_of_statement sexp_of_expr_typed_located sexp_of_stmt_loc s\n\nlet pp_typed_prog ppf prog = pp_prog pp_expr_typed_located pp_stmt_loc ppf prog\n\n(* ===================== Some helper functions and values ====================== *)\nlet no_loc = {filename= \"\"; line_num= 0; col_num= 0; included_from= None}\nlet no_span = {begin_loc= no_loc; end_loc= no_loc}\n\nlet internal_expr =\n  { texpr= Var \"UHOH\"\n  ; texpr_loc= no_span\n  ; texpr_type= UInt\n  ; texpr_adlevel= DataOnly }\n\nlet zero = {internal_expr with texpr= Lit (Int, \"0\"); texpr_type= UInt}\n\n(* Internal function names *)\nlet fn_length = \"Length__\"\nlet fn_make_array = \"MakeArray__\"\nlet fn_make_rowvec = \"MakeRowVec__\"\nlet fn_negative_infinity = \"NegativeInfinity__\"\nlet fn_read_data = \"ReadData__\"\nlet fn_read_param = \"ReadParam__\"\nlet fn_constrain = \"Constrain__\"\nlet fn_unconstrain = \"Unconstrain__\"\nlet fn_check = \"Check__\"\nlet fn_print = \"Print__\"\nlet fn_reject = \"Reject__\"\n"}}}
Found a `dune` file at /home/enetsee/Workspace/enetsee/stanc3/src/mir
]] Making a new jbuilder package at /home/enetsee/Workspace/enetsee/stanc3/src/mir
=== Project root: /home/enetsee/Workspace/enetsee/stanc3
Detected `opam` dependency manager for local use
=== Build dir:    /home/enetsee/Workspace/enetsee/stanc3/_build
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /home/enetsee/Workspace/enetsee/stanc3/src/mir/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":11,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/mir/Mir.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00286102294922ms
Found a `dune` file at /home/enetsee/Workspace/enetsee/stanc3/src/mir
]] Making a new jbuilder package at /home/enetsee/Workspace/enetsee/stanc3/src/mir
=== Project root: /home/enetsee/Workspace/enetsee/stanc3
Detected `opam` dependency manager for local use
=== Build dir:    /home/enetsee/Workspace/enetsee/stanc3/_build
Sending response {"id": 11, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/enetsee/Workspace/enetsee/stanc3/src/mir/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":12,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/mir/Mir.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00309944152832ms
Found a `dune` file at /home/enetsee/Workspace/enetsee/stanc3/src/mir
]] Making a new jbuilder package at /home/enetsee/Workspace/enetsee/stanc3/src/mir
=== Project root: /home/enetsee/Workspace/enetsee/stanc3
Detected `opam` dependency manager for local use
=== Build dir:    /home/enetsee/Workspace/enetsee/stanc3/_build
Sending response {"id": 12, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: Unable to read /home/enetsee/Workspace/enetsee/stanc3/src/mir/.merlin", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":13,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/mir/Mir.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Found a `dune` file at /home/enetsee/Workspace/enetsee/stanc3/src/mir
]] Making a new jbuilder package at /home/enetsee/Workspace/enetsee/stanc3/src/mir
=== Project root: /home/enetsee/Workspace/enetsee/stanc3
Detected `opam` dependency manager for local use
=== Build dir:    /home/enetsee/Workspace/enetsee/stanc3/_build
Sending response {"id": 13, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/enetsee/Workspace/enetsee/stanc3/src/mir/.merlin"}}
Found a `dune` file at /home/enetsee/Workspace/enetsee/stanc3/src/mir
]] Making a new jbuilder package at /home/enetsee/Workspace/enetsee/stanc3/src/mir
=== Project root: /home/enetsee/Workspace/enetsee/stanc3
Detected `opam` dependency manager for local use
=== Build dir:    /home/enetsee/Workspace/enetsee/stanc3/_build
Read message 
{"jsonrpc":"2.0","id":14,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/mir/Mir.ml"},"position":{"line":10,"character":28}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/enetsee/Workspace/enetsee/stanc3/src/mir
]] Making a new jbuilder package at /home/enetsee/Workspace/enetsee/stanc3/src/mir
=== Project root: /home/enetsee/Workspace/enetsee/stanc3
Detected `opam` dependency manager for local use
=== Build dir:    /home/enetsee/Workspace/enetsee/stanc3/_build
Sending response {"id": 14, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/enetsee/Workspace/enetsee/stanc3/src/mir/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":15,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/mir/Mir.ml"},"position":{"line":10,"character":28}}}
[server] Got a method textDocument/definition
[server] processing took 0.00786781311035ms
Found a `dune` file at /home/enetsee/Workspace/enetsee/stanc3/src/mir
]] Making a new jbuilder package at /home/enetsee/Workspace/enetsee/stanc3/src/mir
=== Project root: /home/enetsee/Workspace/enetsee/stanc3
Detected `opam` dependency manager for local use
=== Build dir:    /home/enetsee/Workspace/enetsee/stanc3/_build
Sending response {"id": 15, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/enetsee/Workspace/enetsee/stanc3/src/mir/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":16,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/mir/Mir.ml"},"position":{"line":10,"character":27}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Found a `dune` file at /home/enetsee/Workspace/enetsee/stanc3/src/mir
]] Making a new jbuilder package at /home/enetsee/Workspace/enetsee/stanc3/src/mir
=== Project root: /home/enetsee/Workspace/enetsee/stanc3
Detected `opam` dependency manager for local use
=== Build dir:    /home/enetsee/Workspace/enetsee/stanc3/_build
Sending response {"id": 16, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/enetsee/Workspace/enetsee/stanc3/src/mir/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":17,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/mir/Mir.ml"},"position":{"line":10,"character":27}}}
[server] Got a method textDocument/hover
[server] processing took 0.00500679016113ms
Found a `dune` file at /home/enetsee/Workspace/enetsee/stanc3/src/mir
]] Making a new jbuilder package at /home/enetsee/Workspace/enetsee/stanc3/src/mir
=== Project root: /home/enetsee/Workspace/enetsee/stanc3
Detected `opam` dependency manager for local use
=== Build dir:    /home/enetsee/Workspace/enetsee/stanc3/_build
Sending response {"id": 17, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /home/enetsee/Workspace/enetsee/stanc3/src/mir/.merlin"}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeWatchedFiles","params":{"changes":[{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/bin/.merlin","type":1},{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/mir/.merlin","type":1},{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/_build/default/src/bin/.merlin","type":1},{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/_build/default/src/mir/.merlin","type":1},{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/_build/default/test/integration/.merlin","type":2},{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/test/integration/.merlin","type":2},{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.merlin","type":2},{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/.merlin","type":2}]}}
Got a watched file change
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Ast_to_Mir.ml","languageId":"ocaml","version":1,"text":"open Core_kernel\nopen Mir\n\n(* XXX fix exn *)\nlet unwrap_return_exn = function\n  | Some (ReturnType ut) -> ut\n  | x -> raise_s [%message \"Unexpected return type \" (x : returntype option)]\n\nlet rec op_to_funapp op args =\n  { texpr= FunApp (Operators.operator_name op, trans_exprs args)\n  ; texpr_type= Operators.operator_return_type op args |> unwrap_return_exn\n  ; texpr_loc= Ast.expr_loc_lub args\n  ; texpr_adlevel= Ast.expr_ad_lub args }\n\nand trans_expr\n    { Ast.expr_typed\n    ; expr_typed_type= texpr_type\n    ; expr_typed_loc= texpr_loc\n    ; expr_typed_ad_level= texpr_adlevel } =\n  match expr_typed with\n  | Ast.Paren x -> trans_expr x\n  | BinOp (lhs, op, rhs) -> op_to_funapp op [lhs; rhs]\n  | PrefixOp (op, e) | Ast.PostfixOp (e, op) -> op_to_funapp op [e]\n  | _ ->\n      let texpr =\n        match expr_typed with\n        | Ast.TernaryIf (cond, ifb, elseb) ->\n            TernaryIf (trans_expr cond, trans_expr ifb, trans_expr elseb)\n        | Variable {name; _} -> Var name\n        | IntNumeral x -> Lit (Int, x)\n        | RealNumeral x -> Lit (Real, x)\n        | FunApp ({name; _}, args) | Ast.CondDistApp ({name; _}, args) ->\n            FunApp (name, trans_exprs args)\n        | GetLP | GetTarget -> Var \"target\"\n        | ArrayExpr eles -> FunApp (fn_make_array, trans_exprs eles)\n        | RowVectorExpr eles -> FunApp (fn_make_rowvec, trans_exprs eles)\n        | Indexed (lhs, indices) ->\n            Indexed (trans_expr lhs, List.map ~f:trans_idx indices)\n        | Paren _ | BinOp _ | PrefixOp _ | PostfixOp _ ->\n            raise_s [%message \"Impossible!\"]\n      in\n      {texpr; texpr_type; texpr_loc; texpr_adlevel}\n\nand trans_idx = function\n  | Ast.All -> All\n  | Ast.Upfrom e -> Upfrom (trans_expr e)\n  | Ast.Downfrom e -> Downfrom (trans_expr e)\n  | Ast.Between (lb, ub) -> Between (trans_expr lb, trans_expr ub)\n  | Ast.Single e -> (\n    match e.expr_typed_type with\n    | UInt -> Single (trans_expr e)\n    | UArray _ -> MultiIndex (trans_expr e)\n    | _ ->\n        raise_s\n          [%message \"Expecting int or array\" (e.expr_typed_type : unsizedtype)]\n    )\n\nand trans_exprs = List.map ~f:trans_expr\n\nlet trans_sizedtype = map_sizedtype trans_expr\n\nlet neg_inf =\n  { texpr_type= UReal\n  ; texpr_loc= no_span\n  ; texpr= FunApp (fn_negative_infinity, [])\n  ; texpr_adlevel= DataOnly }\n\nlet lbind s =\n  match s.stmt with SList ls | Block ls -> ls | Skip -> [] | _ -> [s]\n\nlet add_to_or_create_block source target =\n  {target with stmt= Block ({target with stmt= source} :: lbind target)}\n\nlet trans_arg (adtype, ut, ident) = (adtype, ident.Ast.name, ut)\n\nlet truncate_dist ast_obs t =\n  let trunc cond_op x y =\n    let sloc = x.Ast.expr_typed_loc in\n    { sloc\n    ; stmt=\n        IfElse\n          (op_to_funapp cond_op [ast_obs; x], {sloc; stmt= TargetPE neg_inf}, y)\n    }\n  in\n  match t with\n  | Ast.NoTruncate -> []\n  | TruncateUpFrom lb -> [trunc Ast.Less lb None]\n  | TruncateDownFrom ub -> [trunc Ast.Greater ub None]\n  | TruncateBetween (lb, ub) ->\n      [trunc Ast.Less lb (Some (trunc Ast.Greater ub None))]\n\nlet unquote s =\n  if s.[0] = '\"' && s.[String.length s - 1] = '\"' then\n    String.drop_suffix (String.drop_prefix s 1) 1\n  else s\n\n(* hack(sean): strings aren't real\n   XXX add UString to MIR and maybe AST.\n*)\nlet mkstring texpr_loc s =\n  {texpr= Lit (Str, s); texpr_type= UReal; texpr_loc; texpr_adlevel= DataOnly}\n\nlet trans_printables texpr_loc (ps : Ast.typed_expression Ast.printable list) =\n  List.map\n    ~f:(function\n      | Ast.PString s -> mkstring texpr_loc (unquote s)\n      | Ast.PExpr e -> trans_expr e)\n    ps\n\n(** [add_index expression index] returns an expression that (additionally)\n    indexes into the input [expression] by [index].*)\nlet add_int_index e i =\n  let texpr_type =\n    Semantic_check.inferred_unsizedtype_of_indexed e.texpr_loc e.texpr_type\n      [(i, UInt)]\n  in\n  let mir_i = trans_idx i in\n  let texpr =\n    match e.texpr with\n    | Var _ -> Indexed (e, [mir_i])\n    | Indexed (e, indices) -> Indexed (e, indices @ [mir_i])\n    | _ -> raise_s [%message \"These should go away with Ryan's LHS\"]\n  in\n  {e with texpr; texpr_type}\n\n(** [mkfor] returns a MIR For statement that iterates over the given expression\n    [iteratee]. *)\nlet mkfor bodyfn iteratee sloc =\n  let idx s =\n    let expr_typed = Ast.Variable {name= s; id_loc= sloc} in\n    Ast.Single\n      { Ast.expr_typed_loc= sloc\n      ; expr_typed\n      ; expr_typed_ad_level= DataOnly\n      ; expr_typed_type= UInt }\n  in\n  let loopvar, reset = Util.gensym_enter () in\n  let lower = {internal_expr with texpr= Lit (Int, \"0\")} in\n  let upper = {internal_expr with texpr= FunApp (fn_length, [iteratee])} in\n  let stmt = Block [bodyfn (add_int_index iteratee (idx loopvar))] in\n  reset () ;\n  {stmt= For {loopvar; lower; upper; body= {stmt; sloc}}; sloc}\n\n(** [for_scalar unsizedtype...] generates a For statement that loops\n    over the scalars in the underlying [unsizedtype].\n\n    We can call [bodyfn] directly on scalars, make a direct For loop\n    around Eigen types, or for Arrays we call mkfor but inserting a\n    recursive call into the [bodyfn] that will operate on the nested\n    type. In this way we recursively create for loops that loop over\n    the outermost layers first.\n*)\nlet rec for_scalar bodyfn var sloc =\n  match var.texpr_type with\n  | UInt | UReal -> bodyfn var\n  | UVector | URowVector | UMatrix -> mkfor bodyfn var sloc\n  | UArray _ -> mkfor (fun e -> for_scalar bodyfn e sloc) var sloc\n  | UFun _ | UMathLibraryFunction ->\n      raise_s [%message \"Can't for over \" (var : expr_typed_located)]\n\n(** [for_eigen unsizedtype...] generates a For statement that loops\n    over the eigen types in the underlying [unsizedtype]; i.e. just iterating\n    overarrays and running bodyfn on any eign types found within.\n\n    We can call [bodyfn] directly on scalars and Eigen types;\n    for Arrays we call mkfor but insert a\n    recursive call into the [bodyfn] that will operate on the nested\n    type. In this way we recursively create for loops that loop over\n    the outermost layers first.\n*)\nlet rec for_eigen bodyfn var sloc =\n  match var.texpr_type with\n  | UInt | UReal | UVector | URowVector | UMatrix -> bodyfn var\n  | UArray _ -> mkfor (fun e -> for_eigen bodyfn e sloc) var sloc\n  | UFun _ | UMathLibraryFunction ->\n      raise_s [%message \"Can't for over \" (var : expr_typed_located)]\n\n(* These types signal the context for a declaration during statement translation.\n   They are only interpreted by trans_decl.*)\ntype readaction = ReadData | ReadParam [@@deriving sexp]\ntype constrainaction = Check | Constrain | Unconstrain [@@deriving sexp]\n\nlet constrainaction_fname = function\n  | Check -> fn_check\n  | Constrain -> fn_constrain\n  | Unconstrain -> fn_unconstrain\n\nlet internal_read_fn dread args =\n  match dread with\n  | ReadData -> FunApp (fn_read_data, args)\n  | ReadParam -> FunApp (fn_read_param, args)\n\ntype decl_context =\n  { dread: readaction option\n  ; dconstrain: constrainaction option\n  ; dadlevel: autodifftype }\n\nlet rec unsizedtype_to_string = function\n  | UMatrix -> \"matrix\"\n  | UVector -> \"vector\"\n  | URowVector -> \"row_vector\"\n  | UReal -> \"real\"\n  | UInt -> \"int\"\n  | UArray t -> unsizedtype_to_string t\n  | t ->\n      raise_s\n        [%message \"Another place where it's weird to get \" (t : unsizedtype)]\n\n(* Well, when you put it like this it does seem a little crazy *)\nlet constraint_to_string t (c : constrainaction) =\n  match t with\n  | Ast.Ordered -> \"ordered\"\n  | PositiveOrdered -> \"positive_ordered\"\n  | Simplex -> \"simplex\"\n  | UnitVector -> \"unit_vector\"\n  | CholeskyCorr -> \"cholesky_factor_corr\"\n  | CholeskyCov -> \"cholesky_factor\"\n  | Correlation -> \"corr_matrix\"\n  | Covariance -> \"cov_matrix\"\n  | Lower _ -> (\n    match c with Check -> \"less_or_equal\" | Constrain | Unconstrain -> \"lb\" )\n  | Upper _ -> (\n    match c with\n    | Check -> \"greater_or_equal\"\n    | Constrain | Unconstrain -> \"ub\" )\n  | LowerUpper _ -> (\n    match c with\n    | Check ->\n        raise_s\n          [%message \"LowerUpper is really two other checks tied together\"]\n    | Constrain | Unconstrain -> \"lub\" )\n  | Offset _ | Multiplier _ | OffsetMultiplier _ -> (\n    match c with Check -> \"\" | Constrain | Unconstrain -> \"offset_multiplier\" )\n  | Identity -> \"\"\n\nlet rec gen_check decl_type decl_id decl_trans sloc adlevel =\n  let chk forl fn args =\n    let texpr_type = remove_size decl_type in\n    forl\n      (fun id ->\n        {stmt= NRFunApp (fn_check, fn :: id :: trans_exprs args); sloc} )\n      {texpr= Var decl_id; texpr_type; texpr_loc= sloc; texpr_adlevel= adlevel}\n      sloc\n  in\n  let constraint_str = mkstring sloc (constraint_to_string decl_trans Check) in\n  match decl_trans with\n  | Identity | Offset _ | Multiplier _ | OffsetMultiplier (_, _) -> []\n  | Lower b | Upper b -> [chk for_scalar constraint_str [b]]\n  | LowerUpper (lb, ub) ->\n      gen_check decl_type decl_id (Lower lb) sloc adlevel\n      @ gen_check decl_type decl_id (Upper ub) sloc adlevel\n  | Ordered | PositiveOrdered | Simplex | UnitVector | CholeskyCorr\n   |CholeskyCov | Correlation | Covariance ->\n      [chk for_eigen constraint_str []]\n\nlet extract_constraint_args = function\n  | Ast.Lower a | Upper a | Offset a | Multiplier a -> [a]\n  | LowerUpper (a1, a2) | OffsetMultiplier (a1, a2) -> [a1; a2]\n  | Ordered | PositiveOrdered | Simplex | UnitVector | CholeskyCorr\n   |CholeskyCov | Correlation | Covariance | Identity ->\n      []\n\n(* use nested funapp for each call to read_data with just the name and size? *)\nlet gen_constraint dconstrain t arg =\n  let mkstring = mkstring arg.texpr_loc in\n  match Option.map ~f:(constraint_to_string t) dconstrain with\n  | None | Some \"\" -> arg\n  | Some constraint_str ->\n      let dc = Option.value_exn dconstrain in\n      let fname = constrainaction_fname dc in\n      let args =\n        arg :: mkstring constraint_str\n        :: mkstring (unsizedtype_to_string arg.texpr_type)\n        :: trans_exprs (extract_constraint_args t)\n      in\n      {arg with texpr= FunApp (fname, args)}\n\nlet rec base_type = function\n  | SArray (t, _) -> base_type t\n  | x -> remove_size x\n\nlet rec base_dims = function\n  | SVector d | SRowVector d -> [d]\n  | SMatrix (d1, d2) -> [d1; d2]\n  | SArray (t, _) -> base_dims t\n  | SInt | SReal -> []\n\nlet mkread id var dread dconstrain sizedtype transform sloc =\n  let read_base var =\n    { var with\n      texpr=\n        internal_read_fn dread\n        @@ (mkstring var.texpr_loc id :: base_dims sizedtype)\n    ; texpr_type= base_type sizedtype }\n  in\n  let constrain var = gen_constraint dconstrain transform (read_base var) in\n  let read_assign var = {stmt= Assignment (var, constrain var); sloc} in\n  for_eigen read_assign var sloc\n\nlet trans_decl {dread; dconstrain; dadlevel} sloc sizedtype transform\n    identifier initial_value =\n  let with_sloc stmt = {stmt; sloc} in\n  let decl_id = identifier.Ast.name in\n  let rhs = Option.map ~f:trans_expr initial_value in\n  let assign rhs =\n    [{stmt= Assignment ({rhs with texpr= Var decl_id}, rhs); sloc}]\n  in\n  let decl_type = trans_sizedtype sizedtype in\n  let decl_var =\n    { texpr= Var decl_id\n    ; texpr_type= remove_size sizedtype\n    ; texpr_adlevel= dadlevel\n    ; texpr_loc= sloc }\n  in\n  let read_stmts =\n    match dread with\n    | Some a -> [mkread decl_id decl_var a dconstrain decl_type transform sloc]\n    | None -> Option.value_map ~default:[] ~f:assign rhs\n  in\n  let decl_adtype =\n    match rhs with\n    | Some {texpr_adlevel; _} -> texpr_adlevel\n    | None -> dadlevel\n  in\n  let decl = Decl {decl_adtype; decl_id; decl_type} |> with_sloc in\n  let checks =\n    match dconstrain with\n    | Some Check -> gen_check decl_type decl_id transform sloc dadlevel\n    | _ -> []\n  in\n  SList ((decl :: read_stmts) @ checks)\n\nlet rec trans_stmt declc {Ast.stmt_typed; stmt_typed_loc= sloc; _} =\n  let trans_stmt = trans_stmt {declc with dread= None; dconstrain= None} in\n  let texpr_loc = sloc in\n  let stmt =\n    match stmt_typed with\n    | Ast.Assignment {assign_indices; assign_rhs; assign_identifier; assign_op}\n      ->\n        let wrap_expr expr_typed =\n          { Ast.expr_typed_loc= sloc\n          ; expr_typed_ad_level= assign_rhs.expr_typed_ad_level\n          ; expr_typed_type= assign_rhs.expr_typed_type\n          ; expr_typed }\n        in\n        let assignee = wrap_expr @@ Ast.Variable assign_identifier in\n        let assignee =\n          match assign_indices with\n          | [] -> assignee\n          | lst -> wrap_expr @@ Ast.Indexed (assignee, lst)\n        in\n        let rhs =\n          match assign_op with\n          | Ast.Assign | Ast.ArrowAssign -> trans_expr assign_rhs\n          | Ast.OperatorAssign op -> op_to_funapp op [assignee; assign_rhs]\n        in\n        Assignment (trans_expr assignee, rhs)\n    | Ast.NRFunApp ({name; _}, args) -> NRFunApp (name, trans_exprs args)\n    | Ast.IncrementLogProb e | Ast.TargetPE e -> TargetPE (trans_expr e)\n    | Ast.Tilde {arg; distribution; args; truncation} ->\n        let add_dist =\n          (* XXX distribution name suffix? *)\n          (* XXX Reminder to differentiate between tilde, which drops constants, and\n             vanilla target +=, which doesn't. Can use _unnormalized or something.*)\n          TargetPE\n            { texpr= FunApp (distribution.name, trans_exprs (arg :: args))\n            ; texpr_loc\n            ; texpr_adlevel= Ast.expr_ad_lub (arg :: args)\n            ; texpr_type= UReal }\n        in\n        SList (truncate_dist arg truncation @ [{sloc; stmt= add_dist}])\n    | Ast.Print ps -> NRFunApp (fn_print, trans_printables sloc ps)\n    | Ast.Reject ps -> NRFunApp (fn_reject, trans_printables sloc ps)\n    | Ast.IfThenElse (cond, ifb, elseb) ->\n        IfElse (trans_expr cond, trans_stmt ifb, Option.map ~f:trans_stmt elseb)\n    | Ast.While (cond, body) -> While (trans_expr cond, trans_stmt body)\n    | Ast.For {loop_variable; lower_bound; upper_bound; loop_body} ->\n        For\n          { loopvar= loop_variable.Ast.name\n          ; lower= trans_expr lower_bound\n          ; upper= trans_expr upper_bound\n          ; body= trans_stmt loop_body }\n    | Ast.ForEach (loopvar, iteratee, body) ->\n        let newsym = Util.gensym () in\n        let wrap texpr =\n          {texpr; texpr_loc; texpr_type= UInt; texpr_adlevel= DataOnly}\n        in\n        let iteratee = trans_expr iteratee\n        and indexing_var = wrap (Var newsym)\n        and body = trans_stmt body in\n        let assign_loopvar =\n          Assignment\n            ( Var loopvar.name |> wrap\n            , Indexed (iteratee, [Single indexing_var]) |> wrap )\n        in\n        For\n          (* XXX Do loops in MIR actually start at 1? *)\n          { loopvar= newsym\n          ; lower= wrap @@ Lit (Int, \"0\")\n          ; upper= wrap @@ FunApp (fn_length, [iteratee])\n          ; body= add_to_or_create_block assign_loopvar body }\n    | Ast.FunDef {returntype; funname; arguments; body} ->\n        FunDef\n          { fdrt=\n              (match returntype with Void -> None | ReturnType ut -> Some ut)\n          ; fdname= funname.name\n          ; fdargs= List.map ~f:trans_arg arguments\n          ; fdbody= trans_stmt body }\n    | Ast.VarDecl\n        {sizedtype; transformation; identifier; initial_value; is_global} ->\n        ignore is_global ;\n        trans_decl declc sloc sizedtype transformation identifier initial_value\n    | Ast.Block stmts -> Block (List.map ~f:trans_stmt stmts)\n    | Ast.Return e -> Return (Some (trans_expr e))\n    | Ast.ReturnVoid -> Return None\n    | Ast.Break -> Break\n    | Ast.Continue -> Continue\n    | Ast.Skip -> Skip\n  in\n  {sloc; stmt}\n\nlet trans_prog filename\n    { Ast.functionblock\n    ; datablock\n    ; transformeddatablock\n    ; parametersblock\n    ; transformedparametersblock\n    ; modelblock\n    ; generatedquantitiesblock } : typed_prog =\n  (*\n     1. prepare_params: add read_param calls (same call should constrain?)\n          maybe read(constrained()), constrain(read()), or read(\"constraint\", ...)\n     1. prepare_params: add tparams 's; add checks\n     2. transform_inits: add read_param calls (same call should unconstrain?)\n     3. prepare_data: add read_data calls and checks\n     4. prepare_data: add tdata 's and checks\n     5. add write() calls to generate_quantities for params, tparams...\n             shit these are conditional depending on the flag.\n             add the flag to the call to write?\n           apparently tdata aren't written anywhere\n\n     during code gen:\n     get_param_names: scan prepare_params for Decl at top level\n     constrained_param_names: needs to tell between tparams and gqs and not\n     unconstrained param names: same, but also some funky\n        adjustments for unconstrained space: ???\n*)\n  let map f list_op = Option.value ~default:[] list_op |> List.map ~f in\n  let grab_names_sizes paramblock block =\n    let get_name_size s =\n      match s.Ast.stmt_typed with\n      | Ast.VarDecl {sizedtype; identifier; _} ->\n          Some (identifier.name, (trans_sizedtype sizedtype, paramblock))\n      | _ -> None\n    in\n    List.map ~f:get_name_size (Option.value ~default:[] block)\n  in\n  let output_vars =\n    [ grab_names_sizes Parameters parametersblock\n    ; grab_names_sizes TransformedParameters transformedparametersblock\n    ; grab_names_sizes GeneratedQuantities generatedquantitiesblock ]\n    |> List.concat |> List.filter_opt\n  and input_vars = grab_names_sizes Data datablock |> List.filter_opt in\n  let prepare_data =\n    map\n      (trans_stmt\n         {dread= Some ReadData; dconstrain= Some Check; dadlevel= DataOnly})\n      datablock\n    @ map\n        (trans_stmt {dread= None; dconstrain= Some Check; dadlevel= DataOnly})\n        transformeddatablock\n  in\n  let prepare_params =\n    map\n      (trans_stmt\n         { dread= Some ReadParam\n         ; dconstrain= Some Constrain\n         ; dadlevel= AutoDiffable })\n      parametersblock\n    @ map\n        (trans_stmt\n           {dread= None; dconstrain= Some Check; dadlevel= AutoDiffable})\n        transformedparametersblock\n  in\n  let generate_quantities =\n    map\n      (trans_stmt {dread= None; dconstrain= Some Check; dadlevel= DataOnly})\n      generatedquantitiesblock\n  in\n  let transform_inits =\n    map\n      (trans_stmt\n         { dread= Some ReadParam\n         ; dconstrain= Some Unconstrain\n         ; dadlevel= DataOnly })\n      parametersblock\n  in\n  { functions_block=\n      (* Should this be AutoDiffable for functions here?*)\n      map\n        (trans_stmt {dread= None; dconstrain= None; dadlevel= AutoDiffable})\n        functionblock\n  ; input_vars\n  ; prepare_data\n  ; prepare_params\n  ; log_prob=\n      map\n        (trans_stmt {dread= None; dconstrain= None; dadlevel= AutoDiffable})\n        modelblock\n  ; generate_quantities\n  ; transform_inits\n  ; output_vars\n  ; prog_name= !Semantic_check.model_name\n  ; prog_path= filename }\n\n(*===================== tests =========================================*)\n\nlet mir_from_string s =\n  Parse.parse_string Parser.Incremental.program s\n  |> Semantic_check.semantic_check_program |> trans_prog \"\"\n\nlet%expect_test \"Prefix-Op-Example\" =\n  let mir =\n    mir_from_string\n      {|\n        model {\n          int i;\n          if (i < -1)\n            print(\"Badger\");\n        }\n      |}\n  in\n  let op = mir.log_prob in\n  print_s [%sexp (op : Mir.stmt_loc list)] ;\n  (* Perhaps this is producing too many nested lists. XXX*)\n  [%expect\n    {|\n      (((Decl (decl_adtype AutoDiffable) (decl_id i) (decl_type SInt)))\n       (IfElse (FunApp Less__ ((Var i) (FunApp PMinus__ ((Lit Int 1)))))\n        (NRFunApp Print__ ((Lit Str Badger))) ())) |}]\n\nlet%expect_test \"read data\" =\n  let m = mir_from_string \"data { matrix[10, 20] mat[5]; }\" in\n  print_s [%sexp (m.prepare_data : stmt_loc list)] ;\n  [%expect\n    {|\n    (((Decl (decl_adtype DataOnly) (decl_id mat)\n       (decl_type (SArray (SMatrix (Lit Int 10) (Lit Int 20)) (Lit Int 5))))\n      (For (loopvar sym1__) (lower (Lit Int 0))\n       (upper (FunApp Length__ ((Var mat))))\n       (body\n        (Block\n         ((Assignment (Indexed (Var mat) ((Single (Var sym1__))))\n           (FunApp ReadData__ ((Lit Str mat) (Lit Int 10) (Lit Int 20)))))))))) |}]\n\nlet%expect_test \"read param\" =\n  let m = mir_from_string \"parameters { matrix<lower=0>[10, 20] mat[5]; }\" in\n  print_s [%sexp (m.prepare_params : stmt_loc list)] ;\n  [%expect\n    {|\n    (((Decl (decl_adtype AutoDiffable) (decl_id mat)\n       (decl_type (SArray (SMatrix (Lit Int 10) (Lit Int 20)) (Lit Int 5))))\n      (For (loopvar sym1__) (lower (Lit Int 0))\n       (upper (FunApp Length__ ((Var mat))))\n       (body\n        (Block\n         ((Assignment (Indexed (Var mat) ((Single (Var sym1__))))\n           (FunApp Constrain__\n            ((FunApp ReadParam__ ((Lit Str mat) (Lit Int 10) (Lit Int 20)))\n             (Lit Str lb) (Lit Str matrix) (Lit Int 0)))))))))) |}]\n\nlet%expect_test \"gen quant\" =\n  let m =\n    mir_from_string \"generated quantities { matrix<lower=0>[10, 20] mat[5]; }\"\n  in\n  print_s [%sexp (m.generate_quantities : stmt_loc list)] ;\n  [%expect\n    {|\n    (((Decl (decl_adtype DataOnly) (decl_id mat)\n       (decl_type (SArray (SMatrix (Lit Int 10) (Lit Int 20)) (Lit Int 5))))\n      (For (loopvar sym1__) (lower (Lit Int 0))\n       (upper (FunApp Length__ ((Var mat))))\n       (body\n        (Block\n         ((For (loopvar sym2__) (lower (Lit Int 0))\n           (upper\n            (FunApp Length__ ((Indexed (Var mat) ((Single (Var sym1__)))))))\n           (body\n            (Block\n             ((NRFunApp Check__\n               ((Lit Str less_or_equal)\n                (Indexed (Var mat) ((Single (Var sym1__)) (Single (Var sym2__))))\n                (Lit Int 0))))))))))))) |}]\n"}}}
Read message 
{"jsonrpc":"2.0","id":18,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Ast_to_Mir.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00309944152832ms
➡️ running bsc /home/enetsee/Workspace/enetsee/stanc3/_opam/bin/ocamlopt.opt -c -I '/home/enetsee/Workspace/enetsee/stanc3/_build/default/src/lib/.stanclib.objs' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/variantslib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/uchar' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/typerep' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/stdio' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/splittable_random' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/sexplib0' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/sexplib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/result' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_sexp_conv/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_inline_test/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_inline_test/config' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_hash/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/config' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/common' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/collector' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_deriving' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_compare/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_bench/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_assert/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/parsexp' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ocaml' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/menhirLib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/jane-street-headers' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/fmt' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/fieldslib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/core_kernel/base_for_tests' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/core_kernel' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/bin_prot/shape' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/bin_prot' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/shadow_stdlib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/md5' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/caml' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ocaml' -bin-annot -open Stanclib -w @a-4-29-40-41-42-44-45-48-58-59-60-40 -strict-sequence -strict-formats -short-paths -keep-locs -g -ppx '/home/enetsee/Workspace/enetsee/stanc3/_build/default/.ppx/0dbe217fe1eb2a8d779ac5e4daea1a6b/ppx.exe --as-ppx --cookie '\''library-name="stanclib"'\''' -impl /home/enetsee/Workspace/enetsee/stanc3/_build/.lsp/stanclib__Ast_to_Mir.ast with pwd /home/enetsee/Workspace/enetsee/stanc3/src/lib
<< Making lastDefinitions with type error for file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Ast_to_Mir.ml
Sending response {"id": 18, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":19,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Ast_to_Mir.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00286102294922ms
Sending response {"id": 19, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: ", "command": ""}}]}
Running diagnostics for file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Ast_to_Mir.ml
type error here File "command line", line 1:
Error: Unbound module Stanclib
Hint: Did you mean Stdlib?
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Ast_to_Mir.ml", "diagnostics": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "message": "File \"command line\", line 1:\nError: Unbound module Stanclib\nHint: Did you mean Stdlib?", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":20,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Ast_to_Mir.ml"},"position":{"line":6,"character":5}}}
[server] Got a method textDocument/hover
[server] processing took 0.00405311584473ms
Sending response {"id": 20, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":21,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Ast_to_Mir.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[{"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"message":"File \"command line\", line 1:\nError: Unbound module Stanclib\nHint: Did you mean Stdlib?","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 21, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":22,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Ast_to_Mir.ml"},"position":{"line":0,"character":3}}}
[server] Got a method textDocument/hover
[server] processing took 0.0100135803223ms
Sending response {"id": 22, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Ast_to_Mir.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/bin/stanc.ml","languageId":"ocaml","version":1,"text":"(** stanc console application *)\n\nopen Core_kernel\nopen Stanclib\n\n(** The main program. *)\nlet version = \"stanc version 3.0 alpha\"\n\nlet name = \"stanc\"\n\n(** The usage message. *)\nlet usage = \"Usage: \" ^ name ^ \" [option] ... <model_file.stan>\"\n\nlet model_file = ref \"\"\nlet pretty_print_program = ref false\nlet print_model_cpp = ref false\nlet dump_mir = ref false\nlet output_file = ref \"\"\n\n(** Some example command-line options here *)\nlet options =\n  Arg.align\n    [ ( \"--debug-lex\"\n      , Arg.Set Debugging.lexer_logging\n      , \" For debugging purposes: print the lexer actions\" )\n    ; ( \"--debug-parse\"\n      , Arg.Set Debugging.grammar_logging\n      , \" For debugging purposes: print the parser actions\" )\n    ; ( \"--debug-ast\"\n      , Arg.Set Debugging.ast_printing\n      , \" For debugging purposes: print the undecorated AST, before semantic \\\n         checking\" )\n    ; ( \"--debug-decorated-ast\"\n      , Arg.Set Debugging.typed_ast_printing\n      , \" For debugging purposes: print the decorated AST, after semantic \\\n         checking\" )\n    ; ( \"--debug-mir\"\n      , Arg.Set dump_mir\n      , \" For debugging purposes: print the MIR.\" )\n    ; ( \"--auto-format\"\n      , Arg.Set pretty_print_program\n      , \" Pretty prints the program to the console\" )\n    ; ( \"--version\"\n      , Arg.Unit\n          (fun _ ->\n            print_endline (version ^ \" \" ^ \"(\" ^ Sys.os_type ^ \")\") ;\n            exit 1 )\n      , \" Display stanc version number\" )\n    ; ( \"--name\"\n      , Arg.Set_string Semantic_check.model_name\n      , \" Take a string to set the model name (default = \\\n         \\\"$model_filename_model\\\")\" )\n    ; ( \"--o\"\n      , Arg.Set_string output_file\n      , \" Take the path to an output file for generated C++ code (default = \\\n         \\\"$name.cpp\\\")\" )\n    ; ( \"--print-cpp\"\n      , Arg.Set print_model_cpp\n      , \" If set, output the generated C++ Stan model class to stdout.\" )\n    ; ( \"--allow_undefined\"\n      , Arg.Clear Semantic_check.check_that_all_functions_have_definition\n      , \" Do not fail if a function is declared but not defined\" )\n    ; ( \"--include_paths\"\n      , Arg.String\n          (fun str ->\n            Preprocessor.include_paths := String.split_on_chars ~on:[','] str\n            )\n      , \" Takes a comma-separated list of directories that may contain a file \\\n         in an #include directive (default = \\\"\\\")\" ) ]\n\nlet model_file_err () =\n  Arg.usage options (\"Please specify one model_file.\\n\\n\" ^ usage) ;\n  exit 127\n\nlet add_file filename =\n  if !model_file = \"\" then model_file := filename else model_file_err ()\n\n(** ad directives from the given file. *)\nlet use_file filename =\n  let ast =\n    try Parse.parse_file Parser.Incremental.program filename\n    with Errors.SyntaxError err ->\n      Errors.report_syntax_error err ;\n      exit 1\n  in\n  let _ = Debugging.ast_logger ast in\n  if !pretty_print_program then\n    print_endline (Pretty_printing.pretty_print_program ast) ;\n  let typed_ast =\n    try Semantic_check.semantic_check_program ast\n    with Errors.SemanticError err ->\n      Errors.report_semantic_error err ;\n      exit 1\n  in\n  let _ = Debugging.typed_ast_logger typed_ast in\n  if not !pretty_print_program then (\n    let mir = Ast_to_Mir.trans_prog filename typed_ast in\n    if !dump_mir then\n      Sexp.pp_hum Format.std_formatter [%sexp (mir : Mir.typed_prog)] ;\n    let cpp = Format.asprintf \"%a\" Stan_math_code_gen.pp_prog mir in\n    Out_channel.write_all !output_file ~data:cpp ;\n    if !print_model_cpp then print_endline cpp )\n\nlet remove_dotstan s = String.drop_suffix s 5\n\nlet main () =\n  (* Parse the arguments. *)\n  Arg.parse options add_file usage ;\n  if !model_file = \"\" then model_file_err () ;\n  if !Semantic_check.model_name = \"\" then\n    Semantic_check.model_name :=\n      remove_dotstan List.(hd_exn (rev (String.split !model_file ~on:'/')))\n      ^ \"_model\" ;\n  if !output_file = \"\" then output_file := remove_dotstan !model_file ^ \".cpp\" ;\n  use_file !model_file\n\nlet () = main ()\n"}}}
Found a `dune` file at /home/enetsee/Workspace/enetsee/stanc3/src/bin
]] Making a new jbuilder package at /home/enetsee/Workspace/enetsee/stanc3/src/bin
=== Project root: /home/enetsee/Workspace/enetsee/stanc3
Detected `opam` dependency manager for local use
=== Build dir:    /home/enetsee/Workspace/enetsee/stanc3/_build
Get ocaml stdlib dirs
Include subdirs? no :/
Got a compiled base /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/bin/.stanc.eobjs
Local file: /home/enetsee/Workspace/enetsee/stanc3/src/bin/stanc.ml
Local .cmt file: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/bin/.stanc.eobjs/Stanc.cmt
Found mir defined in /home/enetsee/Workspace/enetsee/stanc3/src/bin/../mir/dune
Compiled base: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/bin/../mir/.mir.objs
Found stanclib defined in /home/enetsee/Workspace/enetsee/stanc3/src/bin/../lib/dune
Compiled base: /home/enetsee/Workspace/enetsee/stanc3/_build/default/src/bin/../lib/.stanclib.objs
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/variantslib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/uchar
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/typerep
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/stdio
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/splittable_random
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/sexplib0
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/sexplib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/result
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_sexp_conv/runtime-lib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_inline_test/runtime-lib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_inline_test/config
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_hash/runtime-lib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/config
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/common
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/collector
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_deriving
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_compare/runtime-lib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_bench/runtime-lib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_assert/runtime-lib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/parsexp
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ocaml
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/menhirLib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/jane-street-headers
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/fmt
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/fieldslib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/core_kernel/base_for_tests
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/core_kernel
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/bin_prot/shape
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/bin_prot
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/shadow_stdlib
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/md5
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/caml
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base
>> Collecting deps for /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ocaml
Depedency dirs /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/variantslib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/uchar /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/typerep /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/stdio /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/splittable_random /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/sexplib0 /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/sexplib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/result /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_sexp_conv/runtime-lib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_inline_test/runtime-lib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_inline_test/config /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_hash/runtime-lib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/config /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/common /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/collector /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_deriving /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_compare/runtime-lib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_bench/runtime-lib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_assert/runtime-lib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/parsexp /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ocaml /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/menhirLib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/jane-street-headers /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/fmt /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/fieldslib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/core_kernel/base_for_tests /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/core_kernel /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/bin_prot/shape /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/bin_prot /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/shadow_stdlib /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/md5 /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/caml /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base /home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ocaml
>> Build system running: opam exec -- dune build @install --root .
>>> stdout

>>> stderr

Affected files: 
Cleaning bsconfig.json
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/enetsee/Workspace/enetsee/stanc3/src/bin/bsconfig.json", "diagnostics": []}}
Read message 
{"jsonrpc":"2.0","id":23,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/bin/stanc.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00286102294922ms
➡️ running bsc /home/enetsee/Workspace/enetsee/stanc3/_opam/bin/ocamlopt.opt -c -I '/home/enetsee/Workspace/enetsee/stanc3/_build/default/src/bin/.stanc.eobjs' -I '/home/enetsee/Workspace/enetsee/stanc3/_build/default/src/bin/../lib/.stanclib.objs' -I '/home/enetsee/Workspace/enetsee/stanc3/_build/default/src/bin/../mir/.mir.objs' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/variantslib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/uchar' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/typerep' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/stdio' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/splittable_random' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/sexplib0' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/sexplib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/result' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_sexp_conv/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_inline_test/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_inline_test/config' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_hash/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/config' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/common' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/collector' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_deriving' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_compare/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_bench/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_assert/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/parsexp' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ocaml' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/menhirLib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/jane-street-headers' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/fmt' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/fieldslib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/core_kernel/base_for_tests' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/core_kernel' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/bin_prot/shape' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/bin_prot' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/shadow_stdlib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/md5' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/caml' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ocaml' -bin-annot -w @a-4-29-40-41-42-44-45-48-58-59-60-40 -strict-sequence -strict-formats -short-paths -keep-locs -g -ppx '/home/enetsee/Workspace/enetsee/stanc3/_build/default/.ppx/03c5d02a89234e3c15ee43299325fe40/ppx.exe --as-ppx' -impl /home/enetsee/Workspace/enetsee/stanc3/_build/.lsp/Stanc.ast with pwd /home/enetsee/Workspace/enetsee/stanc3/src/bin
Sending response {"id": 23, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Invalid cmt format - probably wrong ocaml version"}}
Running diagnostics for file:///home/enetsee/Workspace/enetsee/stanc3/src/bin/stanc.ml
➡️ running bsc /home/enetsee/Workspace/enetsee/stanc3/_opam/bin/ocamlopt.opt -c -I '/home/enetsee/Workspace/enetsee/stanc3/_build/default/src/bin/.stanc.eobjs' -I '/home/enetsee/Workspace/enetsee/stanc3/_build/default/src/bin/../lib/.stanclib.objs' -I '/home/enetsee/Workspace/enetsee/stanc3/_build/default/src/bin/../mir/.mir.objs' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/variantslib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/uchar' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/typerep' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/stdio' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/splittable_random' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/sexplib0' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/sexplib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/result' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_sexp_conv/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_inline_test/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_inline_test/config' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_hash/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/config' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/common' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/collector' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_deriving' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_compare/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_bench/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_assert/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/parsexp' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ocaml' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/menhirLib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/jane-street-headers' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/fmt' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/fieldslib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/core_kernel/base_for_tests' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/core_kernel' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/bin_prot/shape' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/bin_prot' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/shadow_stdlib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/md5' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/caml' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ocaml' -bin-annot -w @a-4-29-40-41-42-44-45-48-58-59-60-40 -strict-sequence -strict-formats -short-paths -keep-locs -g -ppx '/home/enetsee/Workspace/enetsee/stanc3/_build/default/.ppx/03c5d02a89234e3c15ee43299325fe40/ppx.exe --as-ppx' -impl /home/enetsee/Workspace/enetsee/stanc3/_build/.lsp/Stanc.ast with pwd /home/enetsee/Workspace/enetsee/stanc3/src/bin
Read message 
{"jsonrpc":"2.0","id":24,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/bin/stanc.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00286102294922ms
➡️ running bsc /home/enetsee/Workspace/enetsee/stanc3/_opam/bin/ocamlopt.opt -c -I '/home/enetsee/Workspace/enetsee/stanc3/_build/default/src/bin/.stanc.eobjs' -I '/home/enetsee/Workspace/enetsee/stanc3/_build/default/src/bin/../lib/.stanclib.objs' -I '/home/enetsee/Workspace/enetsee/stanc3/_build/default/src/bin/../mir/.mir.objs' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/variantslib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/uchar' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/typerep' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/stdio' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/splittable_random' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/sexplib0' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/sexplib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/result' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_sexp_conv/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_inline_test/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_inline_test/config' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_hash/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/config' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/common' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_expect/collector' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_deriving' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_compare/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_bench/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ppx_assert/runtime-lib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/parsexp' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ocaml' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/menhirLib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/jane-street-headers' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/fmt' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/fieldslib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/core_kernel/base_for_tests' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/core_kernel' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/bin_prot/shape' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/bin_prot' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/shadow_stdlib' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/md5' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base/caml' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/base' -I '/home/enetsee/Workspace/enetsee/stanc3/_opam/lib/ocaml' -bin-annot -w @a-4-29-40-41-42-44-45-48-58-59-60-40 -strict-sequence -strict-formats -short-paths -keep-locs -g -ppx '/home/enetsee/Workspace/enetsee/stanc3/_build/default/.ppx/03c5d02a89234e3c15ee43299325fe40/ppx.exe --as-ppx' -impl /home/enetsee/Workspace/enetsee/stanc3/_build/.lsp/Stanc.ast with pwd /home/enetsee/Workspace/enetsee/stanc3/src/bin
Sending response {"id": 24, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Invalid cmt format - probably wrong ocaml version", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":24}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Expression_gen.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/mir/Mir.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/bin/stanc.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Ast_to_Mir.ml","languageId":"ocaml","version":1,"text":"open Core_kernel\nopen Mir\n\n(* XXX fix exn *)\nlet unwrap_return_exn = function\n  | Some (ReturnType ut) -> ut\n  | x -> raise_s [%message \"Unexpected return type \" (x : returntype option)]\n\nlet rec op_to_funapp op args =\n  { texpr= FunApp (Operators.operator_name op, trans_exprs args)\n  ; texpr_type= Operators.operator_return_type op args |> unwrap_return_exn\n  ; texpr_loc= Ast.expr_loc_lub args\n  ; texpr_adlevel= Ast.expr_ad_lub args }\n\nand trans_expr\n    { Ast.expr_typed\n    ; expr_typed_type= texpr_type\n    ; expr_typed_loc= texpr_loc\n    ; expr_typed_ad_level= texpr_adlevel } =\n  match expr_typed with\n  | Ast.Paren x -> trans_expr x\n  | BinOp (lhs, op, rhs) -> op_to_funapp op [lhs; rhs]\n  | PrefixOp (op, e) | Ast.PostfixOp (e, op) -> op_to_funapp op [e]\n  | _ ->\n      let texpr =\n        match expr_typed with\n        | Ast.TernaryIf (cond, ifb, elseb) ->\n            TernaryIf (trans_expr cond, trans_expr ifb, trans_expr elseb)\n        | Variable {name; _} -> Var name\n        | IntNumeral x -> Lit (Int, x)\n        | RealNumeral x -> Lit (Real, x)\n        | FunApp ({name; _}, args) | Ast.CondDistApp ({name; _}, args) ->\n            FunApp (name, trans_exprs args)\n        | GetLP | GetTarget -> Var \"target\"\n        | ArrayExpr eles -> FunApp (fn_make_array, trans_exprs eles)\n        | RowVectorExpr eles -> FunApp (fn_make_rowvec, trans_exprs eles)\n        | Indexed (lhs, indices) ->\n            Indexed (trans_expr lhs, List.map ~f:trans_idx indices)\n        | Paren _ | BinOp _ | PrefixOp _ | PostfixOp _ ->\n            raise_s [%message \"Impossible!\"]\n      in\n      {texpr; texpr_type; texpr_loc; texpr_adlevel}\n\nand trans_idx = function\n  | Ast.All -> All\n  | Ast.Upfrom e -> Upfrom (trans_expr e)\n  | Ast.Downfrom e -> Downfrom (trans_expr e)\n  | Ast.Between (lb, ub) -> Between (trans_expr lb, trans_expr ub)\n  | Ast.Single e -> (\n    match e.expr_typed_type with\n    | UInt -> Single (trans_expr e)\n    | UArray _ -> MultiIndex (trans_expr e)\n    | _ ->\n        raise_s\n          [%message \"Expecting int or array\" (e.expr_typed_type : unsizedtype)]\n    )\n\nand trans_exprs = List.map ~f:trans_expr\n\nlet trans_sizedtype = map_sizedtype trans_expr\n\nlet neg_inf =\n  { texpr_type= UReal\n  ; texpr_loc= no_span\n  ; texpr= FunApp (fn_negative_infinity, [])\n  ; texpr_adlevel= DataOnly }\n\nlet lbind s =\n  match s.stmt with SList ls | Block ls -> ls | Skip -> [] | _ -> [s]\n\nlet add_to_or_create_block source target =\n  {target with stmt= Block ({target with stmt= source} :: lbind target)}\n\nlet trans_arg (adtype, ut, ident) = (adtype, ident.Ast.name, ut)\n\nlet truncate_dist ast_obs t =\n  let trunc cond_op x y =\n    let sloc = x.Ast.expr_typed_loc in\n    { sloc\n    ; stmt=\n        IfElse\n          (op_to_funapp cond_op [ast_obs; x], {sloc; stmt= TargetPE neg_inf}, y)\n    }\n  in\n  match t with\n  | Ast.NoTruncate -> []\n  | TruncateUpFrom lb -> [trunc Ast.Less lb None]\n  | TruncateDownFrom ub -> [trunc Ast.Greater ub None]\n  | TruncateBetween (lb, ub) ->\n      [trunc Ast.Less lb (Some (trunc Ast.Greater ub None))]\n\nlet unquote s =\n  if s.[0] = '\"' && s.[String.length s - 1] = '\"' then\n    String.drop_suffix (String.drop_prefix s 1) 1\n  else s\n\n(* hack(sean): strings aren't real\n   XXX add UString to MIR and maybe AST.\n*)\nlet mkstring texpr_loc s =\n  {texpr= Lit (Str, s); texpr_type= UReal; texpr_loc; texpr_adlevel= DataOnly}\n\nlet trans_printables texpr_loc (ps : Ast.typed_expression Ast.printable list) =\n  List.map\n    ~f:(function\n      | Ast.PString s -> mkstring texpr_loc (unquote s)\n      | Ast.PExpr e -> trans_expr e)\n    ps\n\n(** [add_index expression index] returns an expression that (additionally)\n    indexes into the input [expression] by [index].*)\nlet add_int_index e i =\n  let texpr_type =\n    Semantic_check.inferred_unsizedtype_of_indexed e.texpr_loc e.texpr_type\n      [(i, UInt)]\n  in\n  let mir_i = trans_idx i in\n  let texpr =\n    match e.texpr with\n    | Var _ -> Indexed (e, [mir_i])\n    | Indexed (e, indices) -> Indexed (e, indices @ [mir_i])\n    | _ -> raise_s [%message \"These should go away with Ryan's LHS\"]\n  in\n  {e with texpr; texpr_type}\n\n(** [mkfor] returns a MIR For statement that iterates over the given expression\n    [iteratee]. *)\nlet mkfor bodyfn iteratee sloc =\n  let idx s =\n    let expr_typed = Ast.Variable {name= s; id_loc= sloc} in\n    Ast.Single\n      { Ast.expr_typed_loc= sloc\n      ; expr_typed\n      ; expr_typed_ad_level= DataOnly\n      ; expr_typed_type= UInt }\n  in\n  let loopvar, reset = Util.gensym_enter () in\n  let lower = {internal_expr with texpr= Lit (Int, \"0\")} in\n  let upper = {internal_expr with texpr= FunApp (fn_length, [iteratee])} in\n  let stmt = Block [bodyfn (add_int_index iteratee (idx loopvar))] in\n  reset () ;\n  {stmt= For {loopvar; lower; upper; body= {stmt; sloc}}; sloc}\n\n(** [for_scalar unsizedtype...] generates a For statement that loops\n    over the scalars in the underlying [unsizedtype].\n\n    We can call [bodyfn] directly on scalars, make a direct For loop\n    around Eigen types, or for Arrays we call mkfor but inserting a\n    recursive call into the [bodyfn] that will operate on the nested\n    type. In this way we recursively create for loops that loop over\n    the outermost layers first.\n*)\nlet rec for_scalar bodyfn var sloc =\n  match var.texpr_type with\n  | UInt | UReal -> bodyfn var\n  | UVector | URowVector | UMatrix -> mkfor bodyfn var sloc\n  | UArray _ -> mkfor (fun e -> for_scalar bodyfn e sloc) var sloc\n  | UFun _ | UMathLibraryFunction ->\n      raise_s [%message \"Can't for over \" (var : expr_typed_located)]\n\n(** [for_eigen unsizedtype...] generates a For statement that loops\n    over the eigen types in the underlying [unsizedtype]; i.e. just iterating\n    overarrays and running bodyfn on any eign types found within.\n\n    We can call [bodyfn] directly on scalars and Eigen types;\n    for Arrays we call mkfor but insert a\n    recursive call into the [bodyfn] that will operate on the nested\n    type. In this way we recursively create for loops that loop over\n    the outermost layers first.\n*)\nlet rec for_eigen bodyfn var sloc =\n  match var.texpr_type with\n  | UInt | UReal | UVector | URowVector | UMatrix -> bodyfn var\n  | UArray _ -> mkfor (fun e -> for_eigen bodyfn e sloc) var sloc\n  | UFun _ | UMathLibraryFunction ->\n      raise_s [%message \"Can't for over \" (var : expr_typed_located)]\n\n(* These types signal the context for a declaration during statement translation.\n   They are only interpreted by trans_decl.*)\ntype readaction = ReadData | ReadParam [@@deriving sexp]\ntype constrainaction = Check | Constrain | Unconstrain [@@deriving sexp]\n\nlet constrainaction_fname = function\n  | Check -> fn_check\n  | Constrain -> fn_constrain\n  | Unconstrain -> fn_unconstrain\n\nlet internal_read_fn dread args =\n  match dread with\n  | ReadData -> FunApp (fn_read_data, args)\n  | ReadParam -> FunApp (fn_read_param, args)\n\ntype decl_context =\n  { dread: readaction option\n  ; dconstrain: constrainaction option\n  ; dadlevel: autodifftype }\n\nlet rec unsizedtype_to_string = function\n  | UMatrix -> \"matrix\"\n  | UVector -> \"vector\"\n  | URowVector -> \"row_vector\"\n  | UReal -> \"real\"\n  | UInt -> \"int\"\n  | UArray t -> unsizedtype_to_string t\n  | t ->\n      raise_s\n        [%message \"Another place where it's weird to get \" (t : unsizedtype)]\n\n(* Well, when you put it like this it does seem a little crazy *)\nlet constraint_to_string t (c : constrainaction) =\n  match t with\n  | Ast.Ordered -> \"ordered\"\n  | PositiveOrdered -> \"positive_ordered\"\n  | Simplex -> \"simplex\"\n  | UnitVector -> \"unit_vector\"\n  | CholeskyCorr -> \"cholesky_factor_corr\"\n  | CholeskyCov -> \"cholesky_factor\"\n  | Correlation -> \"corr_matrix\"\n  | Covariance -> \"cov_matrix\"\n  | Lower _ -> (\n    match c with Check -> \"less_or_equal\" | Constrain | Unconstrain -> \"lb\" )\n  | Upper _ -> (\n    match c with\n    | Check -> \"greater_or_equal\"\n    | Constrain | Unconstrain -> \"ub\" )\n  | LowerUpper _ -> (\n    match c with\n    | Check ->\n        raise_s\n          [%message \"LowerUpper is really two other checks tied together\"]\n    | Constrain | Unconstrain -> \"lub\" )\n  | Offset _ | Multiplier _ | OffsetMultiplier _ -> (\n    match c with Check -> \"\" | Constrain | Unconstrain -> \"offset_multiplier\" )\n  | Identity -> \"\"\n\nlet rec gen_check decl_type decl_id decl_trans sloc adlevel =\n  let chk forl fn args =\n    let texpr_type = remove_size decl_type in\n    forl\n      (fun id ->\n        {stmt= NRFunApp (fn_check, fn :: id :: trans_exprs args); sloc} )\n      {texpr= Var decl_id; texpr_type; texpr_loc= sloc; texpr_adlevel= adlevel}\n      sloc\n  in\n  let constraint_str = mkstring sloc (constraint_to_string decl_trans Check) in\n  match decl_trans with\n  | Identity | Offset _ | Multiplier _ | OffsetMultiplier (_, _) -> []\n  | Lower b | Upper b -> [chk for_scalar constraint_str [b]]\n  | LowerUpper (lb, ub) ->\n      gen_check decl_type decl_id (Lower lb) sloc adlevel\n      @ gen_check decl_type decl_id (Upper ub) sloc adlevel\n  | Ordered | PositiveOrdered | Simplex | UnitVector | CholeskyCorr\n   |CholeskyCov | Correlation | Covariance ->\n      [chk for_eigen constraint_str []]\n\nlet extract_constraint_args = function\n  | Ast.Lower a | Upper a | Offset a | Multiplier a -> [a]\n  | LowerUpper (a1, a2) | OffsetMultiplier (a1, a2) -> [a1; a2]\n  | Ordered | PositiveOrdered | Simplex | UnitVector | CholeskyCorr\n   |CholeskyCov | Correlation | Covariance | Identity ->\n      []\n\n(* use nested funapp for each call to read_data with just the name and size? *)\nlet gen_constraint dconstrain t arg =\n  let mkstring = mkstring arg.texpr_loc in\n  match Option.map ~f:(constraint_to_string t) dconstrain with\n  | None | Some \"\" -> arg\n  | Some constraint_str ->\n      let dc = Option.value_exn dconstrain in\n      let fname = constrainaction_fname dc in\n      let args =\n        arg :: mkstring constraint_str\n        :: mkstring (unsizedtype_to_string arg.texpr_type)\n        :: trans_exprs (extract_constraint_args t)\n      in\n      {arg with texpr= FunApp (fname, args)}\n\nlet rec base_type = function\n  | SArray (t, _) -> base_type t\n  | x -> remove_size x\n\nlet rec base_dims = function\n  | SVector d | SRowVector d -> [d]\n  | SMatrix (d1, d2) -> [d1; d2]\n  | SArray (t, _) -> base_dims t\n  | SInt | SReal -> []\n\nlet mkread id var dread dconstrain sizedtype transform sloc =\n  let read_base var =\n    { var with\n      texpr=\n        internal_read_fn dread\n        @@ (mkstring var.texpr_loc id :: base_dims sizedtype)\n    ; texpr_type= base_type sizedtype }\n  in\n  let constrain var = gen_constraint dconstrain transform (read_base var) in\n  let read_assign var = {stmt= Assignment (var, constrain var); sloc} in\n  for_eigen read_assign var sloc\n\nlet trans_decl {dread; dconstrain; dadlevel} sloc sizedtype transform\n    identifier initial_value =\n  let with_sloc stmt = {stmt; sloc} in\n  let decl_id = identifier.Ast.name in\n  let rhs = Option.map ~f:trans_expr initial_value in\n  let assign rhs =\n    [{stmt= Assignment ({rhs with texpr= Var decl_id}, rhs); sloc}]\n  in\n  let decl_type = trans_sizedtype sizedtype in\n  let decl_var =\n    { texpr= Var decl_id\n    ; texpr_type= remove_size sizedtype\n    ; texpr_adlevel= dadlevel\n    ; texpr_loc= sloc }\n  in\n  let read_stmts =\n    match dread with\n    | Some a -> [mkread decl_id decl_var a dconstrain decl_type transform sloc]\n    | None -> Option.value_map ~default:[] ~f:assign rhs\n  in\n  let decl_adtype =\n    match rhs with\n    | Some {texpr_adlevel; _} -> texpr_adlevel\n    | None -> dadlevel\n  in\n  let decl = Decl {decl_adtype; decl_id; decl_type} |> with_sloc in\n  let checks =\n    match dconstrain with\n    | Some Check -> gen_check decl_type decl_id transform sloc dadlevel\n    | _ -> []\n  in\n  SList ((decl :: read_stmts) @ checks)\n\nlet rec trans_stmt declc {Ast.stmt_typed; stmt_typed_loc= sloc; _} =\n  let trans_stmt = trans_stmt {declc with dread= None; dconstrain= None} in\n  let texpr_loc = sloc in\n  let stmt =\n    match stmt_typed with\n    | Ast.Assignment {assign_indices; assign_rhs; assign_identifier; assign_op}\n      ->\n        let wrap_expr expr_typed =\n          { Ast.expr_typed_loc= sloc\n          ; expr_typed_ad_level= assign_rhs.expr_typed_ad_level\n          ; expr_typed_type= assign_rhs.expr_typed_type\n          ; expr_typed }\n        in\n        let assignee = wrap_expr @@ Ast.Variable assign_identifier in\n        let assignee =\n          match assign_indices with\n          | [] -> assignee\n          | lst -> wrap_expr @@ Ast.Indexed (assignee, lst)\n        in\n        let rhs =\n          match assign_op with\n          | Ast.Assign | Ast.ArrowAssign -> trans_expr assign_rhs\n          | Ast.OperatorAssign op -> op_to_funapp op [assignee; assign_rhs]\n        in\n        Assignment (trans_expr assignee, rhs)\n    | Ast.NRFunApp ({name; _}, args) -> NRFunApp (name, trans_exprs args)\n    | Ast.IncrementLogProb e | Ast.TargetPE e -> TargetPE (trans_expr e)\n    | Ast.Tilde {arg; distribution; args; truncation} ->\n        let add_dist =\n          (* XXX distribution name suffix? *)\n          (* XXX Reminder to differentiate between tilde, which drops constants, and\n             vanilla target +=, which doesn't. Can use _unnormalized or something.*)\n          TargetPE\n            { texpr= FunApp (distribution.name, trans_exprs (arg :: args))\n            ; texpr_loc\n            ; texpr_adlevel= Ast.expr_ad_lub (arg :: args)\n            ; texpr_type= UReal }\n        in\n        SList (truncate_dist arg truncation @ [{sloc; stmt= add_dist}])\n    | Ast.Print ps -> NRFunApp (fn_print, trans_printables sloc ps)\n    | Ast.Reject ps -> NRFunApp (fn_reject, trans_printables sloc ps)\n    | Ast.IfThenElse (cond, ifb, elseb) ->\n        IfElse (trans_expr cond, trans_stmt ifb, Option.map ~f:trans_stmt elseb)\n    | Ast.While (cond, body) -> While (trans_expr cond, trans_stmt body)\n    | Ast.For {loop_variable; lower_bound; upper_bound; loop_body} ->\n        For\n          { loopvar= loop_variable.Ast.name\n          ; lower= trans_expr lower_bound\n          ; upper= trans_expr upper_bound\n          ; body= trans_stmt loop_body }\n    | Ast.ForEach (loopvar, iteratee, body) ->\n        let newsym = Util.gensym () in\n        let wrap texpr =\n          {texpr; texpr_loc; texpr_type= UInt; texpr_adlevel= DataOnly}\n        in\n        let iteratee = trans_expr iteratee\n        and indexing_var = wrap (Var newsym)\n        and body = trans_stmt body in\n        let assign_loopvar =\n          Assignment\n            ( Var loopvar.name |> wrap\n            , Indexed (iteratee, [Single indexing_var]) |> wrap )\n        in\n        For\n          (* XXX Do loops in MIR actually start at 1? *)\n          { loopvar= newsym\n          ; lower= wrap @@ Lit (Int, \"0\")\n          ; upper= wrap @@ FunApp (fn_length, [iteratee])\n          ; body= add_to_or_create_block assign_loopvar body }\n    | Ast.FunDef {returntype; funname; arguments; body} ->\n        FunDef\n          { fdrt=\n              (match returntype with Void -> None | ReturnType ut -> Some ut)\n          ; fdname= funname.name\n          ; fdargs= List.map ~f:trans_arg arguments\n          ; fdbody= trans_stmt body }\n    | Ast.VarDecl\n        {sizedtype; transformation; identifier; initial_value; is_global} ->\n        ignore is_global ;\n        trans_decl declc sloc sizedtype transformation identifier initial_value\n    | Ast.Block stmts -> Block (List.map ~f:trans_stmt stmts)\n    | Ast.Return e -> Return (Some (trans_expr e))\n    | Ast.ReturnVoid -> Return None\n    | Ast.Break -> Break\n    | Ast.Continue -> Continue\n    | Ast.Skip -> Skip\n  in\n  {sloc; stmt}\n\nlet trans_prog filename\n    { Ast.functionblock\n    ; datablock\n    ; transformeddatablock\n    ; parametersblock\n    ; transformedparametersblock\n    ; modelblock\n    ; generatedquantitiesblock } : typed_prog =\n  (*\n     1. prepare_params: add read_param calls (same call should constrain?)\n          maybe read(constrained()), constrain(read()), or read(\"constraint\", ...)\n     1. prepare_params: add tparams 's; add checks\n     2. transform_inits: add read_param calls (same call should unconstrain?)\n     3. prepare_data: add read_data calls and checks\n     4. prepare_data: add tdata 's and checks\n     5. add write() calls to generate_quantities for params, tparams...\n             shit these are conditional depending on the flag.\n             add the flag to the call to write?\n           apparently tdata aren't written anywhere\n\n     during code gen:\n     get_param_names: scan prepare_params for Decl at top level\n     constrained_param_names: needs to tell between tparams and gqs and not\n     unconstrained param names: same, but also some funky\n        adjustments for unconstrained space: ???\n*)\n  let map f list_op = Option.value ~default:[] list_op |> List.map ~f in\n  let grab_names_sizes paramblock block =\n    let get_name_size s =\n      match s.Ast.stmt_typed with\n      | Ast.VarDecl {sizedtype; identifier; _} ->\n          Some (identifier.name, (trans_sizedtype sizedtype, paramblock))\n      | _ -> None\n    in\n    List.map ~f:get_name_size (Option.value ~default:[] block)\n  in\n  let output_vars =\n    [ grab_names_sizes Parameters parametersblock\n    ; grab_names_sizes TransformedParameters transformedparametersblock\n    ; grab_names_sizes GeneratedQuantities generatedquantitiesblock ]\n    |> List.concat |> List.filter_opt\n  and input_vars = grab_names_sizes Data datablock |> List.filter_opt in\n  let prepare_data =\n    map\n      (trans_stmt\n         {dread= Some ReadData; dconstrain= Some Check; dadlevel= DataOnly})\n      datablock\n    @ map\n        (trans_stmt {dread= None; dconstrain= Some Check; dadlevel= DataOnly})\n        transformeddatablock\n  in\n  let prepare_params =\n    map\n      (trans_stmt\n         { dread= Some ReadParam\n         ; dconstrain= Some Constrain\n         ; dadlevel= AutoDiffable })\n      parametersblock\n    @ map\n        (trans_stmt\n           {dread= None; dconstrain= Some Check; dadlevel= AutoDiffable})\n        transformedparametersblock\n  in\n  let generate_quantities =\n    map\n      (trans_stmt {dread= None; dconstrain= Some Check; dadlevel= DataOnly})\n      generatedquantitiesblock\n  in\n  let transform_inits =\n    map\n      (trans_stmt\n         { dread= Some ReadParam\n         ; dconstrain= Some Unconstrain\n         ; dadlevel= DataOnly })\n      parametersblock\n  in\n  { functions_block=\n      (* Should this be AutoDiffable for functions here?*)\n      map\n        (trans_stmt {dread= None; dconstrain= None; dadlevel= AutoDiffable})\n        functionblock\n  ; input_vars\n  ; prepare_data\n  ; prepare_params\n  ; log_prob=\n      map\n        (trans_stmt {dread= None; dconstrain= None; dadlevel= AutoDiffable})\n        modelblock\n  ; generate_quantities\n  ; transform_inits\n  ; output_vars\n  ; prog_name= !Semantic_check.model_name\n  ; prog_path= filename }\n\n(*===================== tests =========================================*)\n\nlet mir_from_string s =\n  Parse.parse_string Parser.Incremental.program s\n  |> Semantic_check.semantic_check_program |> trans_prog \"\"\n\nlet%expect_test \"Prefix-Op-Example\" =\n  let mir =\n    mir_from_string\n      {|\n        model {\n          int i;\n          if (i < -1)\n            print(\"Badger\");\n        }\n      |}\n  in\n  let op = mir.log_prob in\n  print_s [%sexp (op : Mir.stmt_loc list)] ;\n  (* Perhaps this is producing too many nested lists. XXX*)\n  [%expect\n    {|\n      (((Decl (decl_adtype AutoDiffable) (decl_id i) (decl_type SInt)))\n       (IfElse (FunApp Less__ ((Var i) (FunApp PMinus__ ((Lit Int 1)))))\n        (NRFunApp Print__ ((Lit Str Badger))) ())) |}]\n\nlet%expect_test \"read data\" =\n  let m = mir_from_string \"data { matrix[10, 20] mat[5]; }\" in\n  print_s [%sexp (m.prepare_data : stmt_loc list)] ;\n  [%expect\n    {|\n    (((Decl (decl_adtype DataOnly) (decl_id mat)\n       (decl_type (SArray (SMatrix (Lit Int 10) (Lit Int 20)) (Lit Int 5))))\n      (For (loopvar sym1__) (lower (Lit Int 0))\n       (upper (FunApp Length__ ((Var mat))))\n       (body\n        (Block\n         ((Assignment (Indexed (Var mat) ((Single (Var sym1__))))\n           (FunApp ReadData__ ((Lit Str mat) (Lit Int 10) (Lit Int 20)))))))))) |}]\n\nlet%expect_test \"read param\" =\n  let m = mir_from_string \"parameters { matrix<lower=0>[10, 20] mat[5]; }\" in\n  print_s [%sexp (m.prepare_params : stmt_loc list)] ;\n  [%expect\n    {|\n    (((Decl (decl_adtype AutoDiffable) (decl_id mat)\n       (decl_type (SArray (SMatrix (Lit Int 10) (Lit Int 20)) (Lit Int 5))))\n      (For (loopvar sym1__) (lower (Lit Int 0))\n       (upper (FunApp Length__ ((Var mat))))\n       (body\n        (Block\n         ((Assignment (Indexed (Var mat) ((Single (Var sym1__))))\n           (FunApp Constrain__\n            ((FunApp ReadParam__ ((Lit Str mat) (Lit Int 10) (Lit Int 20)))\n             (Lit Str lb) (Lit Str matrix) (Lit Int 0)))))))))) |}]\n\nlet%expect_test \"gen quant\" =\n  let m =\n    mir_from_string \"generated quantities { matrix<lower=0>[10, 20] mat[5]; }\"\n  in\n  print_s [%sexp (m.generate_quantities : stmt_loc list)] ;\n  [%expect\n    {|\n    (((Decl (decl_adtype DataOnly) (decl_id mat)\n       (decl_type (SArray (SMatrix (Lit Int 10) (Lit Int 20)) (Lit Int 5))))\n      (For (loopvar sym1__) (lower (Lit Int 0))\n       (upper (FunApp Length__ ((Var mat))))\n       (body\n        (Block\n         ((For (loopvar sym2__) (lower (Lit Int 0))\n           (upper\n            (FunApp Length__ ((Indexed (Var mat) ((Single (Var sym1__)))))))\n           (body\n            (Block\n             ((NRFunApp Check__\n               ((Lit Str less_or_equal)\n                (Indexed (Var mat) ((Single (Var sym1__)) (Single (Var sym2__))))\n                (Lit Int 0))))))))))))) |}]\n"}}}
Read message 
{"jsonrpc":"2.0","id":25,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Ast_to_Mir.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[{"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"message":"File \"command line\", line 1:\nError: Unbound module Stanclib\nHint: Did you mean Stdlib?","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00405311584473ms
Sending response {"id": 25, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":26,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Ast_to_Mir.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00405311584473ms
Sending response {"id": 26, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: ", "command": ""}}]}
Running diagnostics for file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Ast_to_Mir.ml
type error here File "command line", line 1:
Error: Unbound module Stanclib
Hint: Did you mean Stdlib?
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Ast_to_Mir.ml", "diagnostics": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "message": "File \"command line\", line 1:\nError: Unbound module Stanclib\nHint: Did you mean Stdlib?", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":27,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Ast_to_Mir.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[{"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"message":"File \"command line\", line 1:\nError: Unbound module Stanclib\nHint: Did you mean Stdlib?","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 27, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":28,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///home/enetsee/Workspace/enetsee/stanc3/src/lib/Ast_to_Mir.ml"},"range":{"start":{"line":16,"character":33},"end":{"line":16,"character":33}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0121593475342ms
Sending response {"id": 28, "jsonrpc": "2.0", "result": null}
