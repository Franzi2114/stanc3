{0 Exposing New Functions to stanc3}



{1 Background}

For a function to be built into Stan, it has to be included in the Stan Math library and its signature has to be
exposed to the compiler.

To do the latter, we have to add a corresponding line in [src/middle/Stan_math_signatures.ml].
The compiler uses the signatures defined there to do type checking.


{1 Adding a distribution function }
To add a distribution, we have to find the line containing [let distributions =]. The existing distributions can be
used for reference. The first argument defines the type of function we want to add.
The second argument is the function name without the [_...] part. The third argument specifies
the argument types of the function. The last argument describes whether the return type can be represented as an
Array of Structs (AoS) or as a Struct of Arrays (SoA). The following line exposes a function [foo_lpdf] which takes in
two real numbers:
{[
  ; ([Lpdf], "foo", [DVReal; DVReal], SoA)
]}

For overloaded functions, we need to add a signature for each combination of variable types. If [foo_lpdf] admits either
an integer or a real as its first argument, the proper way to expose the function would be:
{[
  ; ([Lpdf], "foo", [DVReal; DVReal], SoA)
  ; ([Lpdf], "foo", [DVInt; DVReal], SoA)
]}

{1 Adding a normal function}
Standard functions (e.g., not distributions or variadic functions) are added to a list in the same file.
This list begins near the bottom of the file with the line

{[
(* -- Start populating stan_math_signaturess -- *)
let () =
]}


The statements in this list use several helper functions, such as [add_unqualified], [add_qualified],
[add_binary], etc.

The core function of these is [add_qualified], which registers a function based on:
{ol
 {- The name of the function}
 {- The return type (an [UnsizedType.returntype])}
 {- A list of argument types (A list of [UnsizedType.autodifftype * UnsizedType.t] tuples)}
 {- The memory pattern supported by this function, Array of Structs (AoS) or Struct of Arrays (SoA)}
}

All other functions are simply helpers for calling this one. For example, if a function does not have
any arguments it requires to be of type [data], then [add_unqualified] is provided for convience. It
does the same thing as [add_qualfied], but the third argument is just a list of [UnsizedType.t]s.
Other helpers, such as [add_binary], exist for common cases such as a function with a signature
[(real, real) => real]

If a function has multiple signatures, it will generally need multiple calls to these functions.
Some helpers, such as [add_binary_vec] add multiple signatures at once for vectorized functions.

For example, the following line defines the signature [add(real, matrix) => matrix]

{[
  add_unqualified ("add", ReturnType UMatrix, [UReal; UMatrix], SoA) ;
]}

{1 Higher-Order Variadic functions}

Functions such as the ODE integrators or [reduce_sum], which take in user-functions and a variable-length
list of arguments, are {b NOT} added to this list.

These are instead treated as special cases in the [Typechecker] module in the frontend folder. It
it best to consult an existing example of how these are done before proceeding.

{1 Testing}

Functions exposed from the Stan Math Library are tested for all declared signatures. These tests live
in the folder [test/integration/good/function-signatures]. They consist of a basic Stan program (or
multiple programs for functions with a large number of overloads) which call the new function on each
possible combination of arguments.

These tests confirm both that the typechecker accepts these signatures and that the C++ generated
for them compiles against the Math Library implementations.

{1 Documentation}

Finally, before a function can be exposed in the Stan compiler it needs to be added to the Stan
Functions Reference, which is stored at {{:https://github.com/stan-dev/docs}stan-dev/docs}.
New PRs to stanc3 will prompt you to link to the accompanying documentation PR.
